# 经典题型与算法分析

## 1、基础之基础：STL

需要掌握STL中的容器和常见算法的作用和使用方法。

###  1.1 容器

#### 1.1.1 Vector

作用：变长数组。目前几乎在函数传参数方面都使用的是vector。

使用方法：

- 定义：一维数组 `vector<int> v;` 二维数组`vector<viector<int> > v`;初始化(+构造)`vector<int> v(3,100)`;列表初始化`vector<int> v = {1,2}`
- 获取大小 `int cnt = v.size()`;非空判断 `v.empty()`
- 获取迭代器`vector<int>::iterator it = v.begin();vector<int>::iterator it2 = v.end();`在最后插入元素`v.push_back(element)`; 在指定迭代器位置插入`v.insert(it, element)`
- resize和`reserve：resize(count,value)`是要改变v的大小即元素个数，如果v的大小大于count，可以理解为截断；如果v的大小小于count，可以理解为扩充再赋（初）值;`reserve(new_cap)`是预先分配容量空间，一般用这个是减少内存频繁分配时的开销的，他不改变v中元素个数，做题中使用比较少
- 随机访问：`v[index]...v.at(index)`(确保index越界);访问首末元素`front` `back`

#### 1.1.2 对pair

作用：表示一个对的概念。这个概念最常使用在map中的迭代器.也可以简化一些例如二维上点这种对象的定义。有一定用

使用方法：

- 定义以及初始化：`pair<int, int> point;`；`pair<int,int> point(1,2)`；`pair<int, int> point = make_pair(1,2)`
- 访问元素`itr->first` `itr->second`

#### 1.1.3 迭代器

作用：遍历容器；查找类算法 find/lower_bound/upper_bound；容器的insert方法/erase方法等

使用方法：
- 遍历 `for(auto it = v.begin(); it != v.end(); it++)`
- 查找 `auto it = mp.find(key); if (it != mp.end()) { ...}`
- erase `it = v.erase(it)`

#### 1.1.4 string

作用：推荐使用的字符串方式，考试中所有的字符串目前基本不会使用原生的C数组。

使用方法：
- 获取大小和非空判断`cnt = str.size(); if(str.empty()){...}`
- 可以使用下标[]或者at ;访问首末元素`front` `back`
- 拼接 +=/+/append
- 字符串内查找 `s.find(substr, indexbegin)`;`s.rfind(...)`
- 字串substr `s.substr(begin,end)`
- 获取C数组c_str()
- 字符串转数字 stox系列`std::stoi(string("123"))`;数字转字符串to_string系列`int n = 123; string str = std::to_string(n)`


#### 1.1.5 set

作用：包含key的有序列表（逻辑上从小到大）.可以用来做一些标志位的维护和判断

使用方法：
- 获取大小和非空判断`st.size()`,`st.empty()`
- 查找类成员函数（注意，针对set等，直接使用自己的查找类函数）`st.find(key)`,`st.lower_bound(key)// 首个不小余key的迭代器`，`st.upper_bound(key)// 首个大于key的迭代器位置`；`count`用于计数，可以以此判断元素是否存在
- 插入和删除`st.insert(key)`;`st.erase(it); st.erase(key)`
- 遍历。使用迭代器遍历
- 可以指定排序函数cmp（默认使用排序函数为std::less），但是只对标准原生类型建议使用；对于自定义类型，建议重载<运算符实现。
```
	set<int, greater<int>> set1 = {1,2,3};
	set<int > set2 =  { 1,2,3 };
```

#### 1.1.6 map

作用：键值序列。

使用方法：
- 获取大小和非空判断同set；查找类成员函数同set（返回的迭代子指向对象是一个pair）；遍历方法同set；可以指定排序函数cmp（默认使用排序函数为std::less），但是只对标准原生类型建议使用；对于自定义类型，建议重载<运算符实现
- 插入建议直接使用[]完成 `mp[key]=v;`
- 访问：可以使用[]和at或者搭配find使用

#### 1.1.7 栈

作用：后进先出 LIFO序列。表达式求值/括号匹配等场景使用率很高

使用方法：
- 获取大小和非空判断同set
- 访问元栈顶素`top`但不删除
- 向栈顶插入元素 `push`;删除元素`pop`
```C++
  while (!s.empty()) {
    std::cout << s.top()
              << std::endl;
    s.pop();
  }
```

#### 1.1.8 队列

作用：后进先出 LIFO序列，队列常用于BFS

使用方法：
- 获取大小和非空判断同set
- 访问队首元素`front`但不删除
- 向栈顶插入元素 `push`;删除元素`pop`
- 遍历
```C++
  while (!q.empty()) {
    std::cout << q.front()
              << std::endl;
    q.pop();
  }
```

#### 1.1.8 优先级队列

作用：优先级较高的元素先OUT

使用方法：
基本同queue（top取首元素），但是注意下构造方法。
```
priority_queue<int> q1; // int 较小优先级越低
priority_queue<int, vector<int>, greater<int>> q2; // int 较小优先级越高
```

## 题型一、遍历/stl基础用法/基础数据结构相关题目

### 2019.10.18工作级，将两个有序列表合并为一个新的有序列表并返回。

代码中有注释，看懂列表的定义。合并两个有序列表最简单的就是分别遍历两个列表，根据大小关系合并.此题目考察 自定义链表的遍历，插入等技巧
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		// if one list is null, the result must be anather list
		if (l1 == nullptr) {
			return l2;
		}
		else if (l2 == nullptr) {
			return l1;
		}

		ListNode* resultHead = nullptr;
		ListNode* resultCurPos = nullptr;
		if (l1->val > l2->val) { // l1 l2 must be no-null here.
			resultHead = l2;
			l2 = l2->next;
		}
		else {
			resultHead = l1;
			l1 = l1->next;
		}

		resultCurPos = resultHead;
		while (l1 && l2) {  // iterator until one list is over
			if (l1->val > l2->val) {
				resultCurPos->next = l2;
				l2 = l2->next;
			}
			else {
				resultCurPos->next = l1;
				l1 = l1->next;
			}
			resultCurPos = resultCurPos->next;
		}

		// check if l1 or l2 is no-null
		if (l1) {
			resultCurPos->next = l1;
		}
		else {
			resultCurPos->next = l2;
		}
		return resultHead;
	}
};
```

### 2019.10.18工作级，给定一个编码链表和加密条件，对编码进行加密

加密规则：将编码从前往后的第k个元素和从后往前的第k个元素交换。
例如：
```txt
输入:[1,2,3,4,5,6],2
输出为：[1,5,3,4,2,6]
```

此题还是考察自定义链表的遍历等基本操作。倒数第k个节点如果寻找？使用快慢指针类似的方法，让第一个指针先走k-1步，到该指针到达null时第二个指针就是倒数第k个节点











