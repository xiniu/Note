# 经典题型与算法分析

## 1、基础之基础：STL

需要掌握STL中的容器和常见算法的作用和使用方法。

###  1.1 容器

#### 1.1.1 Vector

作用：变长数组。目前几乎在函数传参数方面都使用的是vector。

使用方法：

- 定义：一维数组 `vector<int> v;` 二维数组`vector<viector<int> > v`;初始化(+构造)`vector<int> v(3,100)`;列表初始化`vector<int> v = {1,2}`
- 获取大小 `int cnt = v.size()`;非空判断 `v.empty()`
- 获取迭代器`vector<int>::iterator it = v.begin();vector<int>::iterator it2 = v.end();`在最后插入元素`v.push_back(element)`; 在指定迭代器位置插入`v.insert(it, element)`
- resize和`reserve：resize(count,value)`是要改变v的大小即元素个数，如果v的大小大于count，可以理解为截断；如果v的大小小于count，可以理解为扩充再赋（初）值;`reserve(new_cap)`是预先分配容量空间，一般用这个是减少内存频繁分配时的开销的，他不改变v中元素个数，做题中使用比较少
- 随机访问：`v[index]...v.at(index)`(确保index越界);访问首末元素`front` `back`

#### 1.1.2 对pair

作用：表示一个对的概念。这个概念最常使用在map中的迭代器.也可以简化一些例如二维上点这种对象的定义。有一定用

使用方法：

- 定义以及初始化：`pair<int, int> point;`；`pair<int,int> point(1,2)`；`pair<int, int> point = make_pair(1,2)`
- 访问元素`itr->first` `itr->second`

#### 1.1.3 迭代器

作用：遍历容器；查找类算法 find/lower_bound/upper_bound；容器的insert方法/erase方法等

使用方法：
- 遍历 `for(auto it = v.begin(); it != v.end(); it++)`
- 查找 `auto it = mp.find(key); if (it != mp.end()) { ...}`
- erase `it = v.erase(it)`

#### 1.1.4 string

作用：推荐使用的字符串方式，考试中所有的字符串目前基本不会使用原生的C数组。

使用方法：
- 获取大小和非空判断`cnt = str.size(); if(str.empty()){...}`
- 可以使用下标[]或者at ;访问首末元素`front` `back`
- 拼接 +=/+/append
- 字符串内查找 `s.find(substr, indexbegin)`;`s.rfind(...)`
- 字串substr `s.substr(begin,end)`


#### 1.1.5 set








