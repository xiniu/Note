# 开篇词 C++这么难，为什么我们还要用C++？

## C++是一门多范式的通用编程语言

- 支持面向过程编程
- 支持面向对象编程
- 支持泛型编程
- 新版本还支持函数式编程

## 一些著名的用到C++的场景

- 大型桌面应用程序（Adobe Photoshop、Google Chrome和Microsoft Office）
- 大型网站后台（如Google的搜索引擎）
- 游戏和游戏引擎（Unity）
- 编译器（LLVM/Clang和GCC）
- 解释器（如Java虚拟机和V8 JavaScript引擎）
- 实时控制（战斗机的飞行控制、火星车的自动驾驶系统）
- 视觉和智能引擎（OpenCV、TensorFlow）
- 数据库（MicroSo SQL Server、 MySql、MongoDB）

## C++的竞争力

- 抽象能力：抽象能力代表着更高的开发效率；更为重要的是，不会因此而降低性能
- 性能：快且占用资源少
- 功耗：跟性能相关，性能好了功耗自然低

## 什么时候该用C++

只需要回答一个问题：你在开发上付出的额外时间，能从性能上省回来吗？----C++需要的代码行数一般是Python的三倍左右，而性能可以达到Python的十倍以上。C++是解决性能问题的利器

# 课前必读 有关术语发音及环境要求

## 几个术语

| 英文 | 含义 |
| :--- | :---- |
| decltype |  |
| declval  |  |
| SFINAE   |  |

## 环境要求

大部分时间不会使用超过C++17标准的语言特性。
- 使用GCC的话，推荐使用下面的命令行
```
g++ -std=c++17 -W -Wall -Wfatal-errors filename
```
- 使用MSVC的话：
```
cl /std:c++17 /EHsc /W3 filename
```

# 01 堆、栈、RAII：C++里应该如何管理资源

## 基本概念：

- 堆（heap），在内存管理语境下，指的是动态分配的内存区域（跟数据结构中的堆不是一回事）。这里的内存使用后需要手工释放，否则造成内存泄漏。
- 自由存储区（free store），特指使用new和delete来分配和释放的内存区域，一般而言是堆的子集（new/delete---> free store;  malloc/free--->heap）
- 栈（stack），在内存管理语境下指的是函数调用过程中产生的本地变量和调用数据的区域（跟数据结构的栈高度相似，满足 last-in-first-out--->LIFO）
- RAII（Resource Acquisition Is Initialzation），C++特有的资源管理方式，C++是唯一一个依赖RAII来做资源管理的。RAII依赖栈和析构函数，来对所有资源进行管理

## 堆

使用堆或者说使用动态内存分配，是一件再自然不过的事情

- C++里的new和malloc导致在堆上分配内存（并构造对象）
```
auto ptr = new std::vector<int>();
```
- 历史上看，动态分配内存实际出现较晚。因为动态分配内存带来不确定性：
  - 耗时需要多久
  - 失败了怎么办
  - 至今仍然有很多场合禁用动态内存，例如飞行控制器和电信设备
  
 - 三个基本的内存管理器操作（C++一般只12，Java做13，而Python做123）：
  - 1让内存管理器分配一个某个大下的内存块
  - 2让内存管理器释放一个之前分配的内存块
  - 3让内存管理器做垃圾回收，寻找不再使用的内存并释放 
  - 以上三个内存管理器基本操作都不简单，且彼此之间关联
    - 分配内存要考虑程序当前有多少未分配内存，内存不足时要从操作系统申请新的内存；内存充足时要从可用内存取一块合适大小的内存，做簿记工作标为已用，将内存返回给请求内存的代码
    - 释放内存不只是简单的将内存标记为未使用，对于连续未使用的内存块，需要将其合并，以便满足后续较大的内存分配要求
    - 垃圾回收有很多不同的策略和实现方式。C++通常都不适用垃圾回收
    
大部分软件开发人员不需要担心这些问题。内存分配和释放的管理，是内存管理器的任务，不需要我们介入。我么只需要正确的使用new和delete。我们只需要正确的使用new和delete，每个new出来的对象都应该用delete释放。但这也并不简单。漏掉delele是一种常见的情况，叫内存泄漏。一个简单例子：
```c++
void foo()
{
    bar* ptr = new bar();
    ...
    delete bar;
}
```
以上代码的两个问题：
- 中间省略的代码有可能会抛出异常，导致最后的delete ptr无法执行
- 不符合C++的惯用法，C++中这种情况下99%的可能性不应该使用堆内存分配，而应该使用栈内存分配。

更常见更合理的情况是分配和内存不在一个函数里，这样的话漏delete的可能性更大了
```c++
bar* make_bar(...)
{
    bar* ptr = nullptr;
    try {
        ptr = new bar();
        ...
    }
    catch(...) {
        delete ptr;
        throw;
    }
    return ptr;
}

void foo()
{
    ...
    bar* ptr = make_bar(...);
    ...
    delete ptr;
}
```

## 栈

在包括x86在内的大部分计算机体系结构中，栈的增长方向是低地址。任何一个函数，进入后只能使用进入函数时栈指针向上部分的栈空间。当调用另外一个函数时，也会把参数压入栈（忽略寄存器传参数的情况），然后把下一行汇编指令的地址入栈，并跳转至新的函数。新的函数进入后，首先做一些必须的保存工作，然后调整栈指针，分配出本地变量所需的空间，然后执行代码；执行完毕后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。某个函数占用的栈空间，有个特定的术语叫栈帧（stack frame）

本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起；函数执行完成后，这些内存就自然而然的释放掉了。
- 栈上的分配极为简单，移动栈指针而已
- 释放也极为简单，移动栈指针而已
- 后进先出，不可能出现内存碎片

对于有构造和析构函数的非POD（Plain Old Data）类型，栈上的内存分配也同样有效，C++编译器会在合适的位置插入构造和析构函数的调用。**编译器会自动调用析构函数，包括函数执行发生异常的情况，在发生异常时对于析构函数的调用，叫栈展开（stack unwind）**
```c++
#include<cstdio>
class Obj
{
public:
    Obj() 
    {
        puts("Obj()");
    }
    ~Obj()
    {
        puts("~Obj()");
    }
};

void foo(int n)
{
    Obj obj;
    if (42 == n)
    {
        throw "life, universe and everything";
    }
}
int main()
{
    try {
        foo(41);
        foo(42);
    }
    catch(const char* s)
    {
        puts(s);
    }
}
```
执行结果：注意顺序，如果有异常，在catch之前，栈上的对象就会析构
```
Obj()
~Obj()
Obj()
~Obj()
life, universe and everything
```
在C++里所有的变量缺省都是值语义，跟Java或这Python引用堆上的对象不一样。对于智能指针，ptr->call()和ptr.get()语法上都是对的。值语义和引用语义是C++的特点，也是复杂性的来源

## RAII

C++支持将对象存储在栈上，但是很多情况下不能或者不应该存储在栈上：
- 对象很大
- 对象的大小在编译时不能确定
- 对象是函数的返回值，但是由于某些愿意下，不能使用对象的值返回。

一种常见的情况的，在工厂方法或者面向对象编程的情况下，返回值的类型是基类指针（返回值只能是基类指针，而无法是基类值，否则会发生对象切片，但并不会导致编译错误）.这样该如何保证不会出现内存泄漏呢？
```c++
enum class shape_type {
    circle,
    triangle,
    rectangle
};

class shape
{
public:
    shape() { puts("shape created"); }
    virtual ~shape() { (puts("shape decreated")); }
    virtual void tell() = 0;
};

class circle : public shape
{
public:
    circle() { puts("circle created"); }
    ~circle() { puts("circulr decreated"); }
    void tell() { puts("I'am circle"); }
};

class triangle : public shape
{
public:
    triangle() { puts("triangle created"); }
    ~triangle() { puts("triangle decreated"); }
    void tell() { puts("I'am triangle"); }
};

class rectangle : public shape
{
public:
    rectangle() { puts("rectangle created"); }
    ~rectangle() { puts("rectangle decreated"); }
    void tell() { puts("I'am rectangle"); }
};

shape* create_shape(shape_type type)
{
    switch (type)
    {
    case shape_type::circle:
        return new circle();
    case shape_type::triangle:
        return new triangle();
    case shape_type::rectangle:
        return new rectangle();
    default:
        puts("invalid type");
        return nullptr;
    }
}

int main()
{
    shape* aRectangle = create_shape(shape_type::rectangle);
    aRectangle->tell();
    delete aRectangle; // if missed this, then memory leak
}
```
上述代码的结果如下，同时也用于说明虚函数动态绑定
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
我们怎么才能确保，在使用create_shape的返回值时不会发生内存泄漏么？答案就是析构函数以及栈展开行为。我们只需要把返回值放到一个本地变量，并确认其析构函数会删除该对象。一个简单的实现如下所示：
```c++
class shape_wrapper
{
public:
    explicit shape_wrapper(
        shape* ptr = nullptr)
        : ptr_(ptr) {}
    ~shape_wrapper() { delete ptr_; }
    shape* get() const { return ptr_; }
private:
    shape* ptr_;

};


int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    shape_wrapper ptr_wrapper(
        create_shape(shape_type::rectangle)
    );
    ptr_wrapper.get()->tell();

}
```
输出如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
在new一个对象和delete指针时编译器需要干的活，大致可用如下翻译：new的时候先分配内存，失败时整个操作失败向外抛出异常（bad_alloc），然后在这个结果指针上构造对象，构造成功则整体完成，否则释放内存并向外抛出异常；delete则判断是否为空，不空则调用析构函数并释放内存。
```c++
// new circle()
{
    void* temp =  operator new(sizeof(circle));
    try {
        circle* ptr = 
            static_cast<circle*>(temp);
        ptr->circle();
        return ptr;
    }
    catch(...) {
        operator delete(ptr);
        throw;
    }
}

// delete ptr
{
    if (ptr != nullptr) {
        ptr->~shape();
        operator delete(ptr);
    }
}
```
回到shape_wrapper和他的析构行为，在**析构函数里做必要的清理工作**，这就是RAII的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（fstream的析构函数就是这么做的）
- 释放同步锁
- 释放其他重要的系统资源

例如我们应该使用：
```c++
std::mutex mtx;
void some_func()
{
    std::lock_guard<std::mutex> guard(mtx);
    // do something
}
```
而不是
```c++
std::mutex mtx;
void some_func()
{
    mtx.lock();
    // If exception occure, unlock will not be called
    mtx.unlock();
}
```


## 内容小结

栈是C++里最自然的内存使用方式，基于栈和析构函数的RAII机制，可以有效的对包括堆内存在内的系统资源进行统一管理

## 课后思考 

shape_wrapper和智能指针比起来，还缺少那些功能？ 引用计数/拷贝和移动等

# 02 自己动手，实现C++的智能指针

智能指针本质上并不神秘，就是RAII资源管理功能的自然展现

## 回顾

上一讲的这个类，可以完成智能指针最基本的功能，对超出作用域的对象进行释放，但缺少：
- 这个类只适用于shape类
- 该对象的行为不够像指针
- 拷贝该类对象会引发程序行为异常
逐一弥补这些问题。

## 模板化和易用性

要让这个类能够包装任意类型的指针，需要把他变为一个类模板，模板本身不是特别复杂的特性
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
private:
    T* ptr_;

};
```

另外，需要将其改造，使其行为和指针类似：
- 使用\*运算符解引用
- 使用->指向对象成员
- 和指针一样用在布尔表达式中
添加几个成员函数即可，这里的运算符重载比较奇怪，之前没接触过->和bool()重载
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    if (ptr_smart)
    {
        puts("That's good!");
    }
}
```

结果如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
called bool()
That's good!
rectangle decreated
shape decreated
```

## 拷贝构造和赋值

考虑对于上面的smart_ptr的拷贝行为，如果使用默认的拷贝方法，可能会导致core（对同一块地址释放两次，通常会导致程序奔溃）。
最简单的情况就是禁止拷贝.简单却有效。
```c++
template <typename T>
class smart_ptr {
  …
  smart_ptr(const smart_ptr&)
    = delete;
  smart_ptr& operator=(const smart_ptr&)
    = delete;
  …
};
```
- 是不是可以考虑在拷贝时进行深拷贝？
    - 通常不会这么做，使用智能指针就是要减少对象拷贝
    - 没有办法，只有指针，没有通用的版本可以通过基类指针构造出一个子类对象来
- 试试在拷贝时转移指针的所有权:在拷贝构造函数中，通过release来释放other的指针所有权；在赋值构造中，则通过拷贝
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }

    smart_ptr(smart_ptr& other) { puts("copy ctt called"); ptr_ = other.release(); }
    smart_ptr& operator=(smart_ptr& rhs) { puts("assign ctt called"); smart_ptr(rhs).swap(*this); return *this; }
    T* release() { T* ptr = ptr_; ptr_ = nullptr; return ptr; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    auto ptr_smart2 = ptr_smart;   // it called copy constractor only!!!
    if (ptr_smart)
    {
        puts("That's good!");
    }
    else {
        puts("ptr_smart has been released");
    }
    ptr_smart = ptr_smart2;
}
```
结果如下,注意，并不是说有=出现就是赋值构造。另外，有些赋值构造会写`if (this != &rhs)`，这种写法更罗嗦且异常性不够，如果赋值过程发生异常，this对象的内容可能已经破坏，上面这种代码的惯用法保证了**异常安全性：赋值分为拷贝构造和交换两部，拷贝发生异常，this对象不受任何影响，只存在赋值成功或者没有效果两种状态（swap-idom）**。以上其实是C++98的auto_ptr的行为；但是这个实现很别扭，会让程序员犯错，一不小心传递给另外一个smart_ptr后，你就不再拥有这个对象。
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
copy ctt called
called bool()
ptr_smart has been released
assign ctt called
copy ctt called
rectangle decreated
shape decreated
```

## “移动”指针

使用移动来改善其行为。C++的规则是：如果提供了移动构造函数而没有手动提供拷贝构造函数，那么后者自动被禁用：将smart_ptr&改为了smart_ptr&&，现在成了移动构造函数；把赋值函数中的参数类型由smart_ptr&改为了smart_ptr，在构造参数时生成新的智能指针，移动赋值（这样做的目的是什么？注意570会先调用移动构造构造再调用赋值函数ptr_smart = std::move(ptr_smart2);这个地方还是么有看懂---move之后先成成了一个右值引用&&，然后这时构造=运算符的参数即一个临时对象，这时肯定是通过移动构造构造此参数临时对象，然后就进入=实现了）
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }

    smart_ptr(smart_ptr&& other) { puts("move-copy ctt called"); ptr_ = other.release(); }
    smart_ptr& operator=(smart_ptr rhs) { puts("assign ctt called"); rhs.swap(*this); return *this; }
    T* release() { T* ptr = ptr_; ptr_ = nullptr; return ptr; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    // auto ptr_smart2 = ptr_smart; compile error;
    auto ptr_smart2(std::move(ptr_smart));
    if (ptr_smart)
    {
        puts("That's good!");
    }
    else {
        puts("ptr_smart has been released");
    }
    ptr_smart = std::move(ptr_smart2);
    smart_ptr<shape> ptr_smart3{ create_shape(shape_type::rectangle) };
    //smart_ptr<shape> ptr_smart4{ ptr_smart3 }; compile error
}
```
结果如下
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
move-copy ctt called
called bool()
ptr_smart has been released
move-copy ctt called
assign ctt called
shape created
rectangle created
rectangle decreated
shape decreated
rectangle decreated
shape decreated
```
以上实现就是C++11中unique_ptr的基本行为，其实跟auto_ptr来看效果上一致的，一个对象最终只被一个unique_ptr拥有，只不过这里避免了程序员犯错，需要显式的移动

## 子类指针向基类指针的转化

在C++中circle\*可以隐式转化为shape\*，但是目前的smart_ptr<circle>却无法转化为smart_ptr<shape>.需要额外再改造下，新增一个构造函数，使用模板
```c++  
  template <typename U>
  smart_ptr(smart_ptr<U>&& other)
  {
    ptr_ = other.release();
  }
```
    
## 三五法则
如果需要析构函数，则必定需要拷贝和赋值。

## 引用计数

unique_ptr是一种较为安全的智能指针，但是一个对象智能被单个unique_ptr所拥有。一种更常见的的情况是多个智能指针同时拥有一个对象，通过引用计数跟踪对象是否失效。这就是shared_ptr了。初步实现如下：注意
- 拷贝构造有两个（一个基于模板，一个不是模板），移动构造只有一个（基于模板），我自己分析，如果拷贝构造只保留一个基于模板的话，编译器会自动再生成一个。
- 模板类的多个实例间不是天然就有friend关系，需要明确说明
- 针对移动构造的情况，不需要增加引用计数
```c++
class shared_count
{
public:
    shared_count() noexcept : count_(1) {}
    void add_count() noexcept { ++count_; }
    long reduce_count() noexcept { return --count_; }
    long get_count() const noexcept { return count_; }
private:
    long count_;

};

template <typename T>
class smart_ptr {
public:
    template <typename U>
    friend class smart_ptr;

    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) 
    {
        puts("ctt called");
        if (ptr) {
            shared_count_ = new shared_count();
        }
    }
    ~smart_ptr() 
    {
        if (ptr_ && !shared_count_->reduce_count()) {
            delete ptr_;
            delete shared_count_;
        }
    }

    smart_ptr(const smart_ptr& other) 
    { 
        puts("copy ctt called"); 
        ptr_ = other.ptr_; 
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr(const smart_ptr<U>& other) noexcept
    {
        puts("cast copy ctt called");
        ptr_ = other.ptr_();
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr( smart_ptr<U>&& other) noexcept
    {
        puts("cast move_copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            shared_count_ = other.shared_count_;
            other.ptr_ = nullptr;
        }
    }
	smart_ptr& operator=(smart_ptr rhs) noexcept { puts("assign copy ctt called");  rhs.swap(*this);    return *this; } // it will call copy ctt first to construct "(smart_ptr rhs)"----copy-and-swap idiom
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
	
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); std::swap(shared_count_, rhs.shared_count_);}
    long use_count() const
    {
        if (ptr_) {
            return shared_count_->get_count();
        }
        else {
            return 0;
        }
    }
private:
    T* ptr_;
    shared_count* shared_count_;

};


int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    printf("count of object is %d\n", ptr_smart.use_count());
    // auto ptr_smart2 = ptr_smart; compile error;
    smart_ptr<shape> ptr_smart2(std::move(ptr_smart));
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart3(ptr_smart2);
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart4{ ptr_smart2 };
    printf("count of object is %d\n", ptr_smart2.use_count());

}
```
输出如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
ctt called
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
count of object is 1
cast move_copy ctt called
count of object is 1
copy ctt called
count of object is 2
copy ctt called
count of object is 3
rectangle decreated
shape decreated
```

## 指针类型转化

对于C++里的不同类型的强制转化，需要实现类似的函数模板。但是转化时需要修改智能指针内部的指针对象，需要增加一个构造函数.然后针对四类强制转化实现四个函数模板
```c++
class shared_count
{
public:
    shared_count() noexcept : count_(1) {}
    void add_count() noexcept { ++count_; }
    long reduce_count() noexcept { return --count_; }
    long get_count() const noexcept { return count_; }
private:
    long count_;

};

template <typename T>
class smart_ptr {
public:
    template <typename U>
    friend class smart_ptr;

    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) 
    {
        puts("ctt called");
        if (ptr) {
            shared_count_ = new shared_count();
        }
    }
	template <typename U>
	smart_ptr(const smart_ptr<U>& other, T* ptr)
	{
		puts("explicit cast ctt called");
		ptr_ = ptr;
		if (ptr_) {
			other.shared_count_->add_count();
			shared_count_ = other.shared_count_;
		}
	}
    ~smart_ptr() 
    {
        if (ptr_ && !shared_count_->reduce_count()) {
            delete ptr_;
            delete shared_count_;
        }
    }

    smart_ptr(const smart_ptr& other) 
    { 
        puts("copy ctt called"); 
        ptr_ = other.ptr_; 
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr(const smart_ptr<U>& other) noexcept
    {
        puts("cast copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr( smart_ptr<U>&& other) noexcept
    {
        puts("cast move_copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            shared_count_ = other.shared_count_;
            other.ptr_ = nullptr;
        }
    }
	smart_ptr& operator=(smart_ptr rhs) noexcept { puts("assign copy ctt called");  rhs.swap(*this);    return *this; } // it will call copy ctt first to construct "(smart_ptr rhs)"----copy-and-swap idiom
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); std::swap(shared_count_, rhs.shared_count_);}
    long use_count() const
    {
        if (ptr_) {
            return shared_count_->get_count();
        }
        else {
            return 0;
        }
    }
private:
    T* ptr_;
    shared_count* shared_count_;

};
template <typename T, typename U>
smart_ptr<T> static_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = static_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> reinterpret_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = reinterpret_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> const_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = const_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> dynamic_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = dynamic_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    printf("count of object is %d\n", ptr_smart.use_count());
    // auto ptr_smart2 = ptr_smart; compile error;
    smart_ptr<shape> ptr_smart2(std::move(ptr_smart));
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart3(ptr_smart2);
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart4{ ptr_smart2 };
    printf("count of object is %d\n", ptr_smart2.use_count());

	smart_ptr<rectangle> rec_ptr(new rectangle());
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
	smart_ptr<shape> shape_ptr = rec_ptr;
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
	smart_ptr<rectangle> rec_ptr2 = dynamic_pointer_cast<rectangle>(shape_ptr);
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
}
```
结果如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
ctt called
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
count of object is 1
cast move_copy ctt called
count of object is 1
copy ctt called
count of object is 2
copy ctt called
count of object is 3
shape created
rectangle created
ctt called
count of rec_ptr object is 1
cast copy ctt called
count of rec_ptr object is 2
explicit cast ctt called
count of rec_ptr object is 3
rectangle decreated
shape decreated
rectangle decreated
shape decreated
```

## 课后思考

### copy-and-swap idiom
Any class that manages a resource (a wrapper, like a smart pointer) needs to implement The Big Three. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?

The copy-and-swap idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee.
https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550

### shared_ptr应该具备的其他功能

make_shared

# 03 右值和移动究竟解决了什么问题？

移动语义时C++11里引入的重要概念，这个概念时现代C++里优化的基础

## 值分左右

标准里规定了下面这些值类别（value categories）
![C++表达式值类别](https://static001.geekbang.org/resource/image/18/3c/18b692072537d4ce179d3857a8a0133c.png)

- 一个lvalue是通常可以放在等号左边的表达式，左值
- 一个rvalue是通常只能放在等号右边的表达式，右值
- 一个glvalue是generalized lvalue，广义左值
- 一个xvalue是expiring lvaue，将亡值
- 一个prvalue是pure rvalue，纯右值

lvalue：是有标识符、可以取地址的表达式，最常见的情况：
- 变量、函数、或者数据成员的名字
- 返回左值引用的表达式，如++x、x = 1、cout << ' '
- 字符串字面量如“hello world” （因为可以取地址）
函数调用时，左值可以绑定到左值引用的参数T&。常量智能绑定到常左值引用，const T&。

反之，纯右值prvalue是没有标识符/不可取地址的表达式，一般也称之为“临时对象”：
- 返回非引用类型的表达式，如 x++、x + 1、make_shared<int>(42)
- 除字符串字面量之外的字面量，如42、true
在C++11之前右值可以绑定到常左值引用（const lvalue reference）的参数，如conts T&，不能绑定到非常左值引用。C++11后，多了一种以用类型，右值引用，T&&。增加了一种引用类型后，最然增加了复杂性，但也带来了很多优化的可能性。例如，利用重载，让smart_ptr的构造函数有不同的行为(smart_ptr<U>&& other中的other到底算是左值还是右值呢，他有标识符/地址，所以式左值。右值引用的变量式一个左值)
```c++
template <typename U>
smart_ptr(const smart_ptr<U>& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    other.shared_count_->add_count();
    shared_count_ =
      other.shared_count_;
  }
}
template <typename U>
smart_ptr(smart_ptr<U>&& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    shared_count_ =
      other.shared_count_;
    other.ptr_ = nullptr;
  }
}
```

- 以下代码中,第一个表达式 new circle()是一个纯右值；第二个表达式里的std::move(ptr)，把一个左值强制转化成一个右值引用，而不改变其内用。从实用的角度看，就是个强制类型转化，其结果是指向ptr1的右值引用，这样会选择上面第二个重载。我们可以把std::move(ptr)看作是一个由名字的右值，把这种表达式讲座xvalue，其不能取地址
```c++
smart_ptr<shape> ptr1{new circle()};
smart_ptr<shape> ptr2 = std::move(ptr1);
```
值类别（category）和值类型（type）是两个概念，前者指的是左值右值相关的概念；后者是相对引用类型的一个概念，所有的原生类型、枚举、结构、类都代表值类型，引用和指针式引用类型

## 生命周期和表达式类型

一个变乱给的生命周期在超出作用域时结束。那么临时对象（prvalue）呢？一个临时对象会在包含这个临时对象的完整表达式估值完成后按照生成顺序逆序被销毁，除非有生命周期延迟。以下代码用以说明
```c++
class result
{
public:
	result() { puts("result created"); };
	~result() { puts("result decreated"); };
};
result process_shape(const shape& shape1, const shape& shape2)
{
	puts("process_shape(&)");
	return result();
}

int main()
{
	puts("main");
	process_shape(circle(), triangle());
	puts("main end");

}
```
输出如下，结果对象最先生成最后生成最后析构
```
main
shape created
triangle created
shape created
circle created
process_shape(&)
result created
result decreated
circulr decreated
shape decreated
triangle decreated
shape decreated
main end
```
另外将process_shape的参数改为非常量引用将编译报错，原因就是上面说的，prvalue只能绑定到常左值引用。
```
result process_shape( shape& shape1,  shape& shape2)
{
	puts("process_shape(&)");
	return result();
}
```
为了方便对临时对象的使用，可以将prvalue绑定到一个引用上，他的生命周期将延长到跟这个引用变量一样长。
```c++
int main()
{
	puts("main");
	result &&r = process_shape(circle(), triangle());
	puts("main end");

}
```
结果如下：result的析构被放在了最后
```
main
shape created
triangle created
shape created
circle created
process_shape(&)
result created
circulr decreated
shape decreated
triangle decreated
shape decreated
main end
result decreated
```
但是需要注意，这条规则只对prvalue有效，而对xvalue无效。如果某种原因，prvalue绑定到引用之前已经编程了xvalue，则生命周期不会延长。以下代码中r指向的对象已经不存在了，对r解引用是一个未定义行为。对于C++的这条生命周期延长规则在后面讲到视图view时非常有用。
```
int main()
{
	puts("main");
	result&& r = std::move(process_shape(circle(), triangle()));
	puts("main end");

}
```
```
main
shape created
triangle created
shape created
circle created
process_shape(&)
result created
result decreated
circulr decreated
shape decreated
triangle decreated
shape decreated
main end
```

## 移动的意义

对于smart——ptr，使用右值引用的目的就是实现移动，实现移动的目的时减少运行开销。
以下代码在C++11之前的年代，这种写法时不推荐的。他会引入很多额外的开销:
- 调用构造函数string(const char*),生成临时对象1；“Hello,”复制1次
- 调用operator+（const string&, const string&），生成临时对象2；“Hello，”复制2次，name复制1次
- 调用operator+（const string&, const string&），生成临时对象3；“Hello，”复制3次，name复制2次，“.”复制一次
- 假设返回值优化能够生效，即对象3直接在result里构造完成，不需要析构--（这种优化往往是生效的，我自己写代码也观察到了）
- 析构临时对象2，释放内存
- 析构临时对象1，释放内存
```
string result = string("Hello,") + name + "."
```
在当时一个合格的程序员会这样写,这种写法的代码主要流程如下：
- 调用string(const char*),生成临时对象1；“Hello,”复制1次
- 调用两次string::operator+=，没有临时对象生成；所有字符串只复制一次
```
string result = "Hello, ";
result += name;
result += ".";
```

**但从C++11开始，这不再是必须，同样还是上面的单行语句，执行流程如下**
- 调用构造函数string(const char*),生成临时对象1；“Hello,”复制1次
- 调用operator+(string&&, const string&)，直接在临时对象1上追加操作，并将结果移动到临时对象2；name复制1次
- 调用 operator+(string&&, const char*)，直接在临时对象 2 上面执行追加操作，并把结果移动到 result；"." 复制 1 次。
- 析构临时对象2和1 但是内同已经为空不需要释放任何内存
性能上所有字符串只复制了一次，虽然有临时对象但是不亲车额外的内存分配和释放，相当链接，所示一点点性能，就可以大大增加代码的可读性。

- 为啥C++需要移动语义这一优化
因为在C++里，都是值语义，在类似下面代码中,在Java和Python中会在A对象中放B和C的指针，但是在C++中直接放的是B和C对象。这种行为即是优点也是缺点，因为复制对象的开销会大大增加。移动语义使得C++里返回大对象的函数和运算符成为现实，可以提高代码的简洁性和可读性
```c++
class A {
 B b_;
 C c_;
};
```

## 如何实现移动

要让对象支持移动，需要以下几步：
- 对象应该有分开的考本构造和移动构造函数（除非只打算支持移动不支持拷贝，如unique_ptr）
- 对象应该有swap成员函数，支持和另外一个对象快速交换成员
- 在对象命名空间下，有一个全局的swap函数，调用成员swap韩式实现交换，这种用法会方便别人在其他对象包含你的对象，并快速实现他们的swap函数
- 实现通用的operator=(结合上一节的代码再琢磨琢磨)
- 上面各个函数如果不抛出异常，应当标为noexcept。对移动构造函数尤为重要。

具体写法参照已经实现的smart_ptr
- smart_ptr有拷贝构造和移动构造函数。移动构造函数从另一个对象获取资源，并清空资源，并将其置为一个可析构状态
```c++
smart_ptr(const smart_ptr& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    other.shared_count_
      ->add_count();
    shared_count_ =
      other.shared_count_;
  }
}
template <typename U>
smart_ptr(const smart_ptr<U>& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    other.shared_count_
      ->add_count();
    shared_count_ =
      other.shared_count_;
  }
}
template <typename U>
smart_ptr(smart_ptr<U>&& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    shared_count_ =
      other.shared_count_;
    other.ptr_ = nullptr;
  }
}
```
- smart_ptr有swap成员函数
```
void swap(smart_ptr& rhs) noexcept
{
  using std::swap;
  swap(ptr_, rhs.ptr_);
  swap(shared_count_,
       rhs.shared_count_);
}
```
- 有支持smart_ptr的全局swap函数
```
template <typename T>
void swap(smart_ptr<T>& lhs,
          smart_ptr<T>& rhs) noexcept
{
  lhs.swap(rhs);
}
```
- 通用的=运算符成员函数。下面的写法安全，并且规避了if(&rhs != this)的判断
```
  smart_ptr&
  operator=(smart_ptr rhs) noexcept
  {
    rhs.swap(*this);
    return *this;
  }
```

## 不要返回本地变量的引用

在C++11之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization NRVO），把返回对象直接构造到调用者的栈上；从C++11开始，返回值优化仍可以发生，但在没有返回值优化情况下，编译器将试图将本地对象移动出去而不是拷贝出去。这一行为不需要手动进行std::move，**使用std::move反而会影响返回值优化**
```
class OBJ
{
public:
	OBJ() { puts("OBJ()"); }

	OBJ(const OBJ& obj) noexcept { puts("OBJ(const OBJ& obj)"); }
    OBJ(OBJ&& obj) noexcept { puts("OBJ(OBJ&& obj)"); }
	OBJ& operator=(OBJ rhs) { puts("="); return *this; }
};

OBJ simple()
{
	
	return OBJ(); // 一般有NRVO
}

OBJ simple_with_move()
{
	OBJ obj;
	return std::move(obj); // 禁止NRVO
}

OBJ complicated(int n)
{
	OBJ obj1, obj2; // 有分支，一般不会有NRVO
	if (n % 2 == 0) {
		return obj1;
	}
	else {
		return obj2;
	}
}
int main()
{
	puts("***1***");
	auto a = simple();
	puts("***2***");
	auto b = simple_with_move();
	puts("***3***");
	auto c = complicated(42);
}

```

## 引用坍缩和完美转发

引用坍缩又称为引用折叠，回答下面两个问题：
    - 是不是看到T&，就一定是个左值引用（是）
    - 是不是看到T&&，就一定是右值引用（否）
关键在于：在有模板的代码中，对于类型参数的推导可能是引用：
    - 对于template <typename T> foo(T&&),如果传递的参数是左值，那么T的推导结果就是左值引用；如果传递过去的参数是右值，则T的推导的是参数类型本身
    - 如果T是左值引用，那么T&&的结果仍然是左值引用----即type& &&坍缩呈了type&
    - 如果T是一个实际类型，那么 T&&的结果是一个右值引用。之前也提过，右值引用的变量又会匹配到左值引用上取（what？直接看代码）
```
    void foo(const shape&)
{
	puts("foo(const shape&)");
}

void foo(shape&&)
{
	puts("foo(shape&&)");
}

void bar(const shape& s)
{
	puts("bar(const shape&)");
	foo(s);
}

void bar(shape&& s)
{
	puts("bar(shape&&)");
	foo(s);
}

int main()
{
	bar(circle());
}
```
结果为：
```
shape created
circle created
bar(shape&&)
foo(const shape&)
circulr decreated
shape decreated
```
如果我们要让 bar 调用右值引用的那个 foo 的重载，我们必须写成：
```
foo(std::move(s));
```
但现实情况下如果两个bar的实现都差不多的话，为啥要提供两个不同的bar呢？这个功能在C++标准库里已经实现了，std::forward.这样可以将两个bar简化。
测试代码如下：
```c++
void foo(const shape&)
{
	puts("foo(const shape&)");
}

void foo(shape&&)
{
	puts("foo(shape&&)");
}

template <typename T>
void bar(T&& s)
{
	foo(std::forward<T>(s));
}
int main()
{
	circle t;
	bar(t);
	bar(circle());
}
```
```
shape created
circle created
foo(const shape&)
shape created
circle created
foo(shape&&)
circulr decreated
shape decreated
circulr decreated
shape decreated  
```
因为在 T 是模板参数时，T&& 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。

# 04 容器汇编I：比较简单的若干容器

## 工具

- 原来也有C++版本的Jupyter notebook https://github.com/jupyter-xeus/xeus-cling。在线使用 https://mybinder.org/v2/gh/jupyter-xeus/xeus-cling/stable?filepath=notebooks/xcpp.ipynb 但是速度慢，也可以自己安装，先放弃了
- 作者提供的工具：太牛逼了看不懂
output_container. https://github.com/adah1972/output_container/blob/master/output_container.h

## string

string是模板basic_string对于char类型的特化，可以看成是只能放字符char的容器
- begin获取起始点  C++中的begin和end是半开半闭区间，begin指向第一个元素而end代表最后一个元素之后的位置
- end获取结束点
- empty 是否为空
- size 容器大小
- swap 和另外一个容器交换内容 
一些功能：
- 负责字符串的生命周期
- 支持字符串的拼接操作（+=，append，+）
- 支持字符串的查找（find和rfind）
- 支持从istream安全的读入字符串（使用getline）
- 使用c_str给期待const char\*的接口传递参数
- 支持数字的互转(stoi to_string)
```c++
	string name;
	cout << "What's you name?" << endl;
	getline(cin, name);
	cout << "Nice to meet you, " << name << "\n";
```

## vector

vector允许下面的操作：
- 使用下表访问成员（同string）
- 使用打压获取指向其内容的裸指针（同string）
- 使用capacity湖片区当前分配的存贮空间大小，以元素数量计（同string）
- 使用reserve改变所需的存贮空间，成功后capacity()会变--预分配（同string）
- 使用resize改变其大小，成功后size()改变（同string）
- 使用pop_back删除最后一个元素（同string）
- 使用push_back在哦尾部插入一个元素（同string）
- 使用insert在指定位置前插入（同string）
- 使用earse在指定位置删除一个元素（同string）
- 使用emplace在指定位置构造一个元素
- 使用emplace_back在尾部构造一个元素

**当 push_back、insert、reserve、resize 等函数导致内存重分配时，或当 insert、erase 导致元素位置移动时，vector 会试图把元素“移动”到新的内存区域。vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。**
```
class Obj1 
{ 
public: 
	Obj1() { cout << "Obj1()\n"; } 
	~Obj1() { cout << "~Obj1()\n"; }
	Obj1(const Obj1&) { cout << "Obj1(const Obj1&)\n"; } 
	Obj1(Obj1&&) { cout << "Obj1(Obj1&&)\n"; } 
}; 

class Obj2 
{ 
public: 
	Obj2() { cout << "Obj2()\n"; } 
	~Obj2() { cout << "~Obj2()\n"; }
	Obj2(const Obj2&) { cout << "Obj2(const Obj2&)\n"; } 
	Obj2(Obj2&&) noexcept { cout << "Obj2(Obj2&&)\n"; } 
};


int main()
{
	vector<Obj1> v1;
	v1.reserve(2);
	v1.emplace_back();
	v1.emplace_back();
	v1.emplace_back();
	v1.emplace_back();


	vector<Obj2> v2;
	v2.reserve(2);
	v2.emplace_back();
	v2.emplace_back();
	v2.emplace_back();
	v2.emplace_back();
	v2.emplace_back();
}
```
```
Obj1()
Obj1()
Obj1()
Obj1(const Obj1&)
Obj1(const Obj1&)
~Obj1()
~Obj1()
Obj1()
Obj1(const Obj1&)
Obj1(const Obj1&)
Obj1(const Obj1&)
~Obj1()
~Obj1()
~Obj1()
Obj2()
Obj2()
Obj2()
Obj2(Obj2&&)
Obj2(Obj2&&)
~Obj2()
~Obj2()
Obj2()
Obj2(Obj2&&)
Obj2(Obj2&&)
Obj2(Obj2&&)
~Obj2()
~Obj2()
~Obj2()
Obj2()
Obj2(Obj2&&)
Obj2(Obj2&&)
Obj2(Obj2&&)
Obj2(Obj2&&)
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj2()
~Obj1()
~Obj1()
~Obj1()
~Obj1()
```
C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。你可以试试把 v1.emplace_back() 改成 v1.push_back(Obj1())。对于 vector 里的内容，结果是一样的；但使用 push_back 会额外生成临时对象，多一次（移动或拷贝）构造和析构。
```
int main()
{
	vector<Obj1> v1;
	v1.reserve(2);
	v1.push_back(Obj1());
	v1.push_back(Obj1());
	v1.push_back(Obj1());
	v1.push_back(Obj1());
}
```
输出如下：
```
Obj1()
Obj1(Obj1&&)
~Obj1()
Obj1()
Obj1(Obj1&&)
~Obj1()
Obj1()
Obj1(Obj1&&)
Obj1(const Obj1&)
Obj1(const Obj1&)
~Obj1()
~Obj1()
~Obj1()
Obj1()
Obj1(Obj1&&)
Obj1(const Obj1&)
Obj1(const Obj1&)
Obj1(const Obj1&)
~Obj1()
~Obj1()
~Obj1()
~Obj1()
~Obj1()
~Obj1()
~Obj1()
~Obj1()
```
- vector 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升

## deque
双端队列（double-ended queue）
- 不仅可以从尾部添加和删除元素，也可以从头部
- 提供pushu_front、emplace_front、pop_front
- 不提供data、capacity、reserve函数

规律：
- 如果只从头尾部进行增删操作，容器里的对象永远不需要移动
- 容器里的元素只是部分连续
- 大部分仍然联系，因为遍历性还是比较高
- 支持下表访问容器元素

## list

双向链表，与vector相比，提升了在中间进行插入和删除的操作.如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 list。
- 提供高效的O（1）复杂度任意位置插入和删除
- 不提供下标访问
- 提供pushu_front、emplace_front、pop_front
- 不提供data、capacity、reserve函数
真是新奇了，以前真不知道sort不能再list上使用:).某些标准算法再list上会导致问题，list提供了成员函数作为替代：merge/remove/remove_if/reverse/sort/unique
```
int main()
{
	vector<int> v{ 1,2,3,7,8 };
	sort(v.begin(), v.end());
	cout << v;

	list<int> ll{ 1,2,3,7,8 };
	// sort(ll.begin(), ll.end());  
	ll.sort();
	cout << ll;
}
```

## forward_list

单向链表 0-->1--->2   链表的方向有点反直觉，可能这就是forward的意义吧。他跟list相比缺少以下以下接口：back/size/push_back/emplace_back/pop_back
当元素大小很小时，forward_list能节省的内存时很客观的（从比例来讲），但是用的场景应该很少

## queue

因为queue不是完整的实现，而是依赖某个现有的容器，被称之为容器适配器。queue时FIFO，缺省用deque实现
- 不能按下标访问元素
- 没有begin和end
- 用emplace代替emplace_back,push代替pushu_back，pop代替pop_front，没有其他的push_... pop_... emplace... insert erase方法

因为queue不提供begin和end方法，不能无损遍历，只能用以下方法：
```C++

#include <iostream>
#include <queue>

int main()
{
  std::queue<int> q;
  q.push(1);
  q.push(2);
  q.push(3);
  while (!q.empty()) {
    std::cout << q.front()
              << std::endl;
    q.pop();
  }
}
```

## stack

LIFO的数据结构，缺省也是用deque实现，概念跟vector更相似。但是：
- 不能按小标访问
- 没有begin end
- back成了top，没有front
- 用emplace代替emplace_back,push代替pushu_back，pop代替pop_front，没有其他的push_... pop_... emplace... insert erase方法
```c++

#include <iostream>
#include <stack>

int main()
{
  std::stack<int> s;
  s.push(1);
  s.push(2);
  s.push(3);
  while (!s.empty()) {
    std::cout << s.top()
              << std::endl;
    s.pop();
  }
}
```

# 05 容器汇编II：需要函数对象的容器

## 函数对象及其特化

stl中less大致实现如下。less是模板函数对象，执行任意类型值比较。C+通常默认使用less，包括关联式容器和排序算法。如果需要产生相反顺序，可以使用greater
```C++
	template <class T> 
		struct less : binary_function<T, T, bool> 
	{
		bool operator()(const T& lhs, const T& rhs) {
			return lhs < rhs;
		}
	};
```
计算哈希值的函数对象hash就不一样，他的目的是将一个某种类型的值转化呈一个无符号整数哈希值，没有可默认实现。对于常用类型，提供了需要的特化

```c++
		template <class T> struct hash;
		template <> struct hash<int> : public unary_function<int, size_t>{
			size_t operator()(int v) noexcept {
				return static_cast<size_t>(v);
			}

		}
```
以下例子说明了less和greater的用法以及指针的hash值跟指针值不一样。
```C++
int main()
{
	vector<int> v{ 13,6,4,11,29 };
	cout << v << endl;

	sort(v.begin(), v.end());
	cout << v << endl;

	sort(v.begin(), v.end(), greater<int>());
	cout << v << endl;

	cout << hex;

	auto hp = hash<int*>();
	cout << "hash(nullptr)	 = "
		<< hp(nullptr) << endl;

	cout << "hash(v.data())	 = "
		<< hp(v.data()) << endl;

	cout << "v.data()		 = "
		<< static_cast<void*>(v.data()) << endl;

	auto hs = hash<string>();
	cout << "hash(\"hello\")	= "
		<< hs(string("hello")) << endl;
	cout << "hash(\"hellp\")	= "
		<< hs(string("hellp")) << endl;
}
```

## priority_queue

优先级队列。这是一个容器适配器，会用到比较函数对象。和stack类似，支持push, pop,top等有限操作。容器内的顺序不是FIFO，也不是LIFO，而是排序结果，缺省使用less作为其Compare模板参数，最大的值会出现在容器顶部。

```
using namespace std;
int main()
{
	priority_queue<pair<int, int>, vector<pair<int,int>>,
		greater<pair<int, int> > >q;   // 此处不是函数对象，只是个模板
	q.push({ 1,1 });
	q.push({ 2,2 });
	q.push({ 0,3 });
	q.push({ 9,4 });
	while (!q.empty()) {
		cout << q.top() << endl;
		q.pop();
	}

}
```


## 关联容器

C++的关联容器都是有序的，主要有set/map/multiset/multimap
与序列容器相比，关联容器没有前和后概念，但同样提供了insert/emplace等成员函数，还有find/lower_bound/upper_bound等查找函数，结果是一个迭代器
- find(k) 可以找到一个等价于(!(x < k || x > k))）
- lower_bound(k)找到第一个不小于k的元素，即大于等于 (!(x < k))
- upper_bound(k)找到第一个大于k的元素 (k < x)

对于自定义类型，推荐使用标准less实现，同过重载<对该类型排序。存储在关联容器中的键一般要满足严格弱序关系，通过比较来进行查找和插入删除，复杂度为O(log(n))

## 无序关联容器
从C++11开始提供，每个关联容器都对应一个无序关联容器
- unordered_set
- unordered_map
- unordered_multiset
- unordered_multimap
这些容器的特点是无序，不需要提供一个排序对象，而要求一个计算哈希值的对象。从实际应用角度，无序关联容器的主要优点在于其性能,在选取好的哈希函数情况下，复杂度为O(1)，但是如果选择不当，最差为O（n）。我们需要使用标准的hash函数对象及其特化.注意这里我们直接在std的命名空间添加了特化，这是少数用户可以向std空间添加内容的情况之一。
```C++
using namespace std;

namespace std {
	template <typename T> 
	struct hash<complex<T>> {
		size_t operator()(const complex<T>v) const noexcept {
			hash<T> h;
			return h(v.real()) + h(v.imag());
		}

	};
}
int main()
{
	unordered_set<int> s{ 1,1,2,3,5,8,13,21 };
	cout << s << endl;
	unordered_map<complex<double>, double>
		umc{ {{1.0,2.0}, 1.424 },
		{{3.1,4.1}, 5.0} };
	cout << umc << endl;
}
```

## array
 最后一个容器时C数据的替代品。C数组在C++里继续存在，主要是为了保证兼容性。C数组和C++容器相比差异非常大：
 - 没有begin和end成员函数（虽然可以使用全局的begin和end）
 - 没有size成员韩式
 - 有参数退化行为，传递给一个参数后那个函数不能再获取C数组的长度和结束位置
 
 在C的年代，我们有时候会定位这样的宏来获得数组长度
 ```C
 #define ARRAY_LEN(a) \
 (sizeof(a) / sizeof((a)[0]))
 ```
 如果在一个数组内部使用这个宏，结果肯定是错误。GCC会发出警告 
 C++17中提供了一个size方法，用于获取数组长度，在数组退化成指针情况下会直接失败
 ```C++
 void test(int arr[])
{
	// error!
	// cout << size(arr) << endl;  
}
int main()
{
	int arr[] = { 1,2,3,4,5 };
	cout << "length is " << size(arr) << endl;
	test(arr);
}
 ```
 此外 C数组也没有良好的复制行为。无法用C数组作为map或者onordered_map的键leixing
 如何替代C数组那？
 - 入股数组较大使用vector，vector有最大的灵活性和不错的性能
 - 对应字符串数组 应该首选string
 - 如果数组大小固定并且较小，应该考虑array。array保留了C数组在栈上分配的特点，同时提供了begin/end/size等通用成员函数
 array可以避免C数组的种种怪异。
 ```
 typedef array<char, 8> mykey_t;
void test(mykey_t& arr)
{
	 cout << size(arr) << endl;
}
int main()
{
	mykey_t mykey{"abc"};
	cout << "length is " << size(mykey) << endl;
	test(mykey);
	map <mykey_t, int>mp;
	mp[mykey] = 5;
	cout << mp << endl;
}
 ```
 
 # 06 异常：用还是不用，是个问题
 
 如果你不知道该不该用异常的话，那答案就是改用。如果你需要避免使用异常，那你必须要有明确避免使用异常的理由
 
 ## 没有异常的世界
 
 假设要做一些矩阵操作。可以看到，我们需要大量判断错误的代码，零散分布在代码各处。
 ```C++
 typedef struct {
	float* data;
	size_t nrows;
	size_t ncols;
} matrix;
enum matrix_err_code {
	MATRIX_SUCCESS,
	MATRIX_ERR_MEMORY_INSUFFICENT,
	MATRIX_ERR_MISMATCHED_MATRIX_SIZE
};
int matrix_alloc(matrix* ptr,
	size_t nrows,
	size_t ncols)
{
	size_t size = nrows * ncols * sizeof(float);
	float* data = (float*)malloc(size);
	if (data == NULL) {
		return MATRIX_ERR_MEMORY_INSUFFICENT;
	}
	ptr->data = data;
	ptr->ncols = ncols;
	ptr->nrows = nrows;
	return MATRIX_SUCCESS;
}
void matrix_dealloc(matrix* ptr) {
	if (ptr->data == NULL) {
		return;
	}
	free(ptr);
	ptr->data = NULL;
	ptr->ncols = 0;
	ptr->nrows = 0;
}
int matrix_multiply(matrix* result,
	const matrix* lhs,
	const matrix* rhs)
{
	int errcode;
	if (lhs->ncols != rhs->nrows) {
		return MATRIX_ERR_MISMATCHED_MATRIX_SIZE;
	}
	errcode = matrix_alloc(result, lhs->nrows, rhs->ncols);
	if (errcode != MATRIX_SUCCESS) {
		return errcode;
	}
	// ... do multiply
	return MATRIX_SUCCESS;
}

int main() {
	matrix c;
	memset(c, 0, sizeof(matrix));
	
	errcode = matrix_multiply(c, a, b);
	if (errcode != MATRIX_SUCCESS) {
		goto error_exit;
	}
	// do somthing else
	error_exit:
		matrix_dealloc(&c);
		return errcode;
	
}
 ```
 但是如果我们仅用C++不用异常可以吗？ 你会发现结果好不了多少，c++的构造函数不能返回错误码，所以你根本不能用构造函数做可能出错的事情。你不得不定义一个只清零的构造杉树，再使用init做真正的初始化。
 
 
  ## 使用异常
  
  如果使用异常，我们可以这样写
  ```C++
  class matrix {
	friend matrix operator*(const matrix&, const matrix&);
	matrix(size_t nrows, size_t ncols);
	~matrix();
private:
	float* data_;
	size_t nrows_;
	size_t ncols_;
};
matrix::matrix(size_t nrows, size_t ncols)
{
	data_ = new float[nrows * ncols];
	nrows_ = nrows;
	ncols_ = ncols;
}
matrix::~matrix() {
	delete[] data_;
}
matrix operator*(const matrix& lhs, const matrix& rhs)
{
	if (lhs.ncols_ != rhs.nrows_) {
		throw std::runtime_error(
			"matrix sizes mismatch");
	}
	matrix result(lhs.nrows_, rhs.ncols_);
	// do something
	return result;
}

int main() {
	matrix c = a * b;
	// do something
}
  ```
你可能会疑惑，错误处理在哪儿呢，只有一个throw。事实上，异常处理并不意味着需要显式的写try和catch。基本概念：异常安装是指异常繁盛时，即不会发生资源泄漏，也不会是的系统处在不一致状态：
- 如果时内存分配出错，即new失败，一般会得到异常bad_alloc。对象构造也就失败。在这种情况下，在catch捕捉到异常前，所有栈上对象都已经被析构，资源全部被清理
- 如果矩阵长宽不适合做惩罚，同样会得到一个异常。在使用乘法的地方 c根本不会被狗仔
- 如果在乘法里分配内存失败，同样会得到一个异常，C不会被构造
- 如果a和b时本地变量，然后乘法失败了呢？ 析构函数自动释放内存

只要我们适当组织好代码/利用好RAII，实现菊展的代码和使用矩阵的代码都可以更加简短和清晰。可以在统一在外层的某个地方处理异常，通常会记录日志火灾姐买你上向用户报告

## 避免异常的风格指南

Google的C++风格指南避免异常的原因：存量代码负担，是出于实际考虑。

另外处理历史原因外，也有处于性能等原因禁用异常。但这是历史原因，当前的编译器，在异常关闭和异常开启时应该已经能够产生性能差不多的代码。代价时二进制文件的增加，因为在异常产生的位置需要做栈展开，二进制文件大小约有10%-20%的上升

## 异常的问题

- 违反了“你不用就不需要付出代码”的C++原则
- 异常比较隐晦不容易看出哪些地方发生异常和发生什么异常

个人建议：
1、写异常安全的代码，尤其是模板里。可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容也不产生资源泄漏
2、如果你的代码可能抛出异常，在文档里明确说明
3、对于肯定不抛出异常的代码，将其标为noexcept

## 使用异常理由

标准库的错误处理方式就是异常。在能使用[]运算符的地方，也提供了at成员函数，能够在下标不存在时排除异常。

C++的标准容器在大部分情况下都提供了强异常保证，即一旦发生异常，现场会恢复到调用之前的状态。例如，vector只在提供了保证不抛出异常的移动构造函数情况下使用移动构造，否则会使用拷贝构造。

# 迭代器和好用的新for循环

## 什么是迭代器

迭代器实际上是一组对类型的要求。最基本要求是，从一个端点出发，下一步下一步地到达另一个端点

输入迭代器 input iterator： 支持\*操作取得对象（不要求多次）； 支持++（前置和后置都支持）；begin的返回和end的返回可以比较，判断是否到了特定位置
前向迭代器 forward iterator：在上面基础上允许多次访问
双向迭代器 bidirectional iterator：在上面基础上支持--（前置后后置）
随机迭代器random-access iterator：在上面基础上，支持在整数类型上的+ - += -=进行跳跃式移动；支持[]下标访问；支持大小比较（之前是相等比较），那他就是个随机迭代器
连续迭代器（C++20） 在迭代器i和整数n且保证i+n是合法迭代器前提下，如果还额外满足\*(addressof(\*i) + n)等价与\*(i+n)，即保证迭代器指向的对象在内存里是连续存放的

如果一个类型像输入迭代器，但是*\i只能用做左值而不能读取，就是个输出迭代器

比输入和输出迭代器更底层的就是迭代器，基本要求是：
- 可以被拷贝构造/拷贝赋值/析构
- 支持*
- 支持前置++

## 常用迭代器

最常用的就是容器的iterator类型，一般都定位了iterator和const_iterator，这些迭代器都被定义为输入迭代器或者其派生类型
- vector::iterator和array::iterator可以满足到连续迭代器
- deque::iterator可以满足到随机访问迭代器（记得他的内存只有部分连续）
- list:：iterator满足到双向
- forward_list::iterator满足到前向

很常见的一个输出迭代器是back_inserter返回的类型back_inserter_iterator。可以用这个方便再容器尾部插入；另一个更常见的输出迭代器是ostream_iterator,方便将容器内容“拷贝”到输出流
```C++
int main()
{
	vector<int> v1{ 1,2,3,4,5 };
	vector<int> v2{0};
	copy(v1.begin(), v1.end(), back_inserter(v2));
	copy(v2.begin(), v2.end(),
		ostream_iterator<int>(cout, "#"));
	return 0;

}
```

## 输入行迭代器

假设要按行读入输入中的每行，在定义输入行迭代器之前，可以使用如下方式.
```
striing line;
for(;;) {
	getline(is, line);
	if(!is) {
		break;
	}
	cout << line << endl;
}
```
自定义一个输入行迭代器可以简化上述过程
C++里有些固定的类型要求规范，对于一个迭代器，需要定义下面的类型

```C++
class istream_line_reader
{
public:
	class iterator { // 实现一个InputIterator
	public:
		typedef ptrdiff_t difference_type;
		typedef string value_type;
		typedef const value_type* pointer;
		typedef const value_type& reference;
		typedef input_iterator_tag iterator_category;

	iterator() noexcept
		: stream_(nullptr){}
	explicit iterator(istream& is)
		: stream_(&is) {
		++*this;
	}
	reference operator*() const noexcept {
		return line_;
	}
	pointer operator->() const noexcept {
		return &line_;
	}
	iterator& operator++() {
		getline(*stream_, line_);
		if (!*stream_) {
			stream_ = nullptr;
		}
		return *this;
	}
	iterator operator++(int) {
		iterator temp(*this);
		++* this;
		return temp;
	}
	bool operator==(const iterator& rhs) const noexcept {
		return stream_ == rhs.stream_;
	}

	bool operator!=(const iterator& rhs) const noexcept {
		return !operator==(rhs);
	}
	private:
		istream* stream_;
		string line_;
	};

	istream_line_reader() noexcept :
		stream_(nullptr){}
	explicit istream_line_reader(istream& is) noexcept:
	stream_(&is){
	}
	iterator begin() {
		return iterator(*stream_);
	}
	iterator end() {
		return iterator();
	}
private:
	istream* stream_;
};


int main()
{
	for (const string& line : istream_line_reader(cin)) {
		cout << line << endl;
	}
	return 0;
}
```
一些设计说明：
- difference_type是代表迭代器之间距离的类型，对我们现在这个类型没有什么用
- value_type是迭代器指向的值类型
- pointer是迭代器指向的指针类型
- reference是引用类型
- iterator_category标识是输入迭代器
- 到底应该让\*负责读取还是++复杂读取，这里采用比较简单的做法，++负责读取，\*返回内容
- 默认构造将stream_清空，带参数的构造中，根据传入的输入流设置stream_
- 定义\*和->获取引用和指针，++读取输入流
- 后置++是惯用法，使用前置++和拷贝构造实现
- 在构造时就读取了一次，调用了++，确保在构造后调用\*可以读取内同
- 一旦读取到尾部或则和出错，则stream_被清空，可以依次判断是否到底end()

## 新for循环

上面使用了基于范围的for循环，等价与
```C++
auto&& r = istream_line_reader(is);
auto it = r.begin();
auto end = e.end();
for (; it != end; ++it) {
	const string& line = *it;
	cout << line << endl;
}

```

再对比以下：
```C++
	for (const string& line : istream_line_reader(cin)) {
		cout << line << endl;
	}
	return 0;
```

事实上，新for循环只是语法糖，具体实现跟上面很像
- 获取冒号后面范围表达式的结果，并产生引用，整个循环期间有效；
- 生成遍历这个范围这个范围的迭代器
- 循环

注意生成迭代器这一步不一定调用begin和end成员函数：
- 对于C数组，编译器自动生成指向数组头尾指针
- 对于有begin和end的成员，编译器调用其begin和end
- 否则，在r对象的名空间寻找可以用于r的begin和end函数，调用begin(r)和end(r)

# 08 易用性改进

## 自动类型推断

### auto

编译器自动根据表达式的类型，自动决定变量的类型（c++14开始函数返回类型也可以），不再需要手工声明。但是auto并没有改变C++时静态语言这一事实，这是编译器自动填充而已

自动推导使得下面的累赘代码成为历史
```C++
for(vector<int>::iterator it = v.begin;
	it != v.end(); ++it) {
		//循环体
	}
```
现在可以直接写（如果不适用基于范围的for循环的话）
```C++
for (auto it = v.begin(); it != v.end(); ++it) {
	// 循环体
}
```
不适用自动类型推断，如果容器类型位置，我们还需要加上typename（注意此处const引用还是要求我们写const_iterator作为迭代器类型）
```C++
template <typename T>
void foo(const T& container) {
	for (typename T::const_iterator it = v.begin;
	...
}
```
如果考虑C数组，不适用自动类型推断，就只能使用两个不同的重载（这个地方是个惊喜，竟然可以通过模板处理数组降级的问题）。但是如果使用C++11提供的全局的begin和end函数，代码可以统一
```C++
template <typename T, std::size_t N>
void foo(const T(&a)[N]) {
	cout << "N is " << N << endl;
	typedef const T* ptr_t;
	for (ptr_t it = a, end = a + N; it != end; ++it) {
		cout << *it;
	}
	cout << endl;
}
template <typename T>
void foo(const T& v) {
	for (typename T::const_iterator it = v.begin();
		it != v.end(); ++it) {
		cout << *it;
	}
	cout << endl;
}

template <typename T>
void foo_unify(const T& v) {
	for (auto it = begin(v);
		it != end(v); ++it) {
		cout << *it;
	}
	cout << endl;
}

template <typename T>
void foo_unify_for(const T& v) {
	for (auto &item : v) {
		cout << item;
	}
	cout << endl;
}

int main()
{
	int arr[] = { 1,2,3,4 };
	foo(arr);
	vector<int> vec{ 1,2,3,4 };
	foo(vec);

	foo_unify(arr);
	foo_unify(vec);

	foo_unify_for(arr);
	foo_unify_for(vec);
	return 0;
}
```
自动类型推导降低代码啰嗦成都，也提高了代码抽象性。当你写了一个含auto的表达式时，相当于把auto替换为模板参数的结果
- auto a = expr; 意味着用expr去匹配一个假想的的template <typename T> f(T)函数模板，结果为值类型
- const auto& a = expr；意味着去匹配一个假想的template <typename T> f(const T&)函数模板，结果为常左值引用
- auto&& a = expr; 意味着用expr匹配假想的template <typename T> f(T&&)，根据之前的转发引用和引用坍缩，结果时跟expr值类别相同的引用类型

### decltype

dectype的用途时获得一个表达式的类型，结果可以跟雷奇形一样使用，两个基本用法：
- decltype(变量名)可以获得变量的精确类型
- decltye(表达式)可以获得表达式的引用类型；除非表达式是个纯右值，此时结果仍然是个值类型
如果我们有 int a 那么：
- decltype(a) 会获得int
- decltype((a)) 会获得int&（因为是表达式）
- decltype(a+a)会获得int (因为 a + a 式prvalue)

### decltype(auto)

有个限制时在你下auto时你必须决定你写的时引用类型还是值类型，auto是值类型, auto& 是引用类型， auto&& 是转发引用（可以是左值引用，也可以是右值引用。使用auto无法根据表达式的类型来决定返回值的类型，但是decltype(expr)既可以是引用类型也可以是值类型，因此可以这么写
```
decltype(expr) a = expr;
```
这种写法不能让人满意，所有在C++14引入了decltype（auto），对于上述场景，只需要
```
decltype(auto)a = expr;
```
这种代码主要用在通用的转发函数模板，你根本不知道你调用的函数是否会返回一个引用

### 函数返回值类型推断

从C++14开始，函数返回值也可以用auto或者decltype(auto)来声明。同样的，auto返回值类型，auto& 或者auto&& 返回引用类型；而用decltype(auto)可以根据返回表达式通用的决定返回的是值类型还是引用类型

和这个形式相关的有另外一个语法，后置返回值类型。严格来时这不算类型推导。一般在返回类型比较复杂/特别是返回类型跟参数类型有推导关系会使用这种语法
```
auto foo(参数) -> 返回值类型声明
{
...
}
```
### 类模板的模板参数推导

在C++17之前类模板不能像函数模板一样推导模板参数，也因此催生了像make_pair这样的工具函数。在C++17之前使用pair只能：
```
pair<int, int> pr{1,42};  // 啰嗦

auto pr = make_pair(1,42);
```

而在C++17世界中，这类工具函数已经不必要了，可以直接写
```C++
autp pt{1,42}
```
初次见到array时，觉得他的主要缺点是不能像C数组一样自动崔初始化列表来推导数组大小，C++17中虽然没有只提供一个模板参数，但你可以两个参数都不用写了
```
int a1[] = {1,2,3}; // OK
array< int, 3> a2{1,2,3}; //啰嗦
array a{1，2，3}；  // 完美
```

自动推导机制可以是编译器根据构造函数自动生成：
```
template <typename T>
struct MyObj {
	MyObj(T value);
	...
}

MyBoj obj1{string("hello")};
// 得到MyObj<string>
MyBoj obj1{"hello"};
// 得到MyObj<const char *>
```
但也可以手工干预
```
template <typename T>
struct MyObj {
	MyObj(T value);
	...
}
MyObj<const char *> -> MyObj<string>
MyBoj obj1{string("hello")};
// 得到MyObj<string>
MyBoj obj1{"hello"};
// 得到MyObj<string>
```

### 结构化绑定

这里将的是：如果返回值是个pair，我们希望用两个变量接受，不得不声明两个变量，然后使用tie来接受
```C++
multimap<string, int>::iterator lower, upper;
std::tie(lower, upper) = mmp.equal_range("four");
```
但是在C++17中，可以简化，使用auto声明变量来获取pair和tuple中的各个子项
```
auto [lower, upper] =  mmp.equal_range("four");
```

### 列表初始化

在C++98中标准容器比起C数组最明显的劣势：不能再代码里方便的初始化容器内容
```
int a[] = {1,2,3,4,5};

vector<int> v;
v.push(1);
v.push(2);
...
```
但是再C++11中终于可以用
```C++
vector<int> v {1,2,3,4,5}
```
这个是通用的可以用于各种类的方法，只要声明一个接受initializer_list的构造函数即可

### 统一初始化

C++11引入的新语法，能够代替很多小括号()在变量初始化时的使用。称为统一初始化。

大括号对于构造一个对象而言，最大的好处是避免C++里“最令人恼火的语法分析”。假设你有有1个类，原型如下
```C++
class utf8_to_wstring {
	utf8_to_wstring(const char*);
	operator wchat_t*();
}
```
然后你在Windows下使用该类完成转化文件名打开文件
```C++
ifstream ifs(
	utf8_to_wstring(filename));
```
你随后发现，ifs的行为无论如何都不正常，最终你会发现，上面这个写法被编译器认为跟下面这个写法是等价的,即编译器认为你声明了一个函数而不是一个对象
```
ifstream ifs( utf8_to_wstring filename )
```
如果使用小括号来初始化即可避免此类问题
```
ifstream ifs( utf8_to_wstring{filename});
```
推而广之，你可以在所有初始化对象的地方使用大括号而不是小括号。他还附带一个特点：如果一个构造函数没有标欸explicit时，可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象
```
Obj getObj() {
	return {1.0};
}
```
处理形式上差别外，跟Obj(1.0)的差异时：Obj(1.0)可以调用Obj(int),而使用大括号时编译器会拒绝债转化。这个语法的主要限制：如果类既有初始化列表的构造函数，又有不适用初始化列表的构造函数，编译器会千方百计试图调用使用初始化列表的构造函数，因此建议是：
- 如果类没有使用初始化列表的构造函数，初始化该类对象科全部使用统一初始化
- 如果有，则只引用在初始化列表构造情况

## 类数据成员的默认初始化

C++98中，数据成员可以在构造函数中初始化，但在实践中，如果数据成员很多/构造函数又有多个，逐个初始化是累赘，并且很容漏掉新增的数据成员。C++11新增了语法，允许在声明数据成员时直接给予一个初始化表达式。当前仅当构造杉树的初始化列表中不包括i该数据成员时，该数据成员自动使用初始化表达式进行初始化
```C++
class Complex {
public:
	Complex()
	: re_(0), im_(0){}
	Complex(floar re)
	: re_(re), im_(0){}
	Complex(floar re, floar im)
	: re_(re), im_(im){}
	...
private:
	float re_;
	float im_;
}
```

如果使用数据成员的默认初始化，可以这么写
```
class Complex {
public:
	Complex(){}
	Complex(floar re)
	: re_(re){}
	Complex(floar re, floar im)
	: re_(re), im_(im){}
	...
private:
	float re_{0};
	float im_{0};
}
```

# 09 易用性改进II：字面量、静态断言和成员函数说明符

## 自定义字面量

字面量（literal）是指源代码中写出的固定常量，在C++中只能是原生类型：
- “hello”，字符串字面量，类型是const char[6]
- 1, 整数字面量，类型是int
- 0.0 浮点数字面量，类型是double
- 3.14f 浮点数字面量，类型是float
- 123456789il，无符号长整形字面量

 C++11引入了自定义字面量，使用operator“”例如（operator""i， operator"" ms,operator"" s）后缀将用户提供的字面量转化成实际类型；C++14在标准库中加入了不少标准字面量。我感觉就是一些单位,后者说将根据表达式生成对应的对象。
```
int main()
{
	cout << "i * i = " << 1i * 1i << endl;
	cout << "waiting 500ms" << endl;
	this_thread::sleep_for(500ms);
	cout << "Hello World"s.substr(0, 5) << endl;
	return 0;
}
```
输出如下：
```
i * i = (-1,0)
waiting 500ms
Hello
```
自定义字面量的方法：
```
struct length {
	double value;
	enum unit {
		metre,
		kilometre,
		millimetre,
		centimetre,
		inch,
		foot,
		yard,
		mile,
	};
	static constexpr double factors[] =
		{ 1.0,	1000.0,	1e-3,
		1e-2,	0.0254,	0.03048,
		0.9144,	1609.344 };
	explicit length(double v, unit u = metre) {
		value = v * factors[u];
	}
};
length operator+ (length lhs, length rhs) {
	return length(lhs.value + rhs.value);
}
length operator""_m(long double v) {
	return length(v, length::metre);
}
length operator""_cm(long double v) {
	return length(v, length::centimetre);
}
int main()
{
	length l1 = 1.0_m;
	length l2 = 1.0_cm;
	length l3 = l1 + l2;
	cout << l3.value << endl;
	return 0;
}
```
输出如下
```
1.01
```

## 二进制字面量

C++里已有的0x标识12进制字面量以及0后买你跟0-7的数字表示八进制字面量。从c++14有了二进制字面量，对于比特级操作还是非常有用的。但目前没有办法直接使用I/O流输出（I/O流目前只有dec，hex，oct三个操作器）。间接的方法是使用bitset
```C++
int main()
{
	unsigned mask = 0b111000000;
	cout << bitset<9>(mask) << endl;
	return 0;
}
```

## 数字分割符

C++14开始允许在任意位置添加‘使其可读

```C++
	unsigned mask = 0b111'000'000;
	long r_earth_equatorial = 6'378'137;
	double pi = 3.14159'26535'89793;
	const unsigned magic = 0x44'42'4E;
```

## 静态断言

C++98的assert允许在运行时检查一个函数的前置条件是否成立，没有一种方法允许在开发编译阶段检查假设是否成立。C++11从羽凡曾main提供了静态断言，能输出更好的信息，实用性也很好，可以直接放在类的定义中。在我看来，应该用在模板编程中，这块需要后面再学习

## default和delete函数

默认的规则示范复杂。我们现在可以通过代码控制，是否需要默认的构造函数。例如一般提供了构造函数后默认构造函数就不会生成，但是我们还是需要，可以用default关键字.以下代码还说明了static_assert的用法
```
template <typename T>
class my_array {
public:

	my_array(size_t size) {
		_size = size; 
		static_assert((sizeof T == 1), "Error 1"); 
	}
	my_array() = default;
	
private:
	T* data_{ nullptr };
	size_t _size{ 0 };

};
int main()
{
	my_array<char> Arr;
	my_array<int> iArr(1);
	return 0;
}
```
同时，再第一讲中如果我们不想对象被拷贝，则可以将拷贝构造和拷贝赋值声明为=delete。在C++11之前我们可能会用private段里声明这些成员函数的方法来达到相似的目的，但是现在这种语法效果更好。

## override和final说明符

他们是说明符，但不是关键字，仅出现在函数声明尾部时起作用，不影响其他将其使用为变量名等其他用途，可以单个或者组合使用，都是加在类成员函数的尾部

override显示声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有该声明的函数不是虚函数，或基类不存在这个虚函数，编译器或报错
- 给开发人员更明确的提示，这个函数腹泻了基类的成员函数
- 让编译器进行额外的检查

final则声明了成员函数时一个虚函数，且该虚函数不可在派生类被覆盖，否则编译器会报错

final还有一个作用是标志某个类或者接哦古不可派生，将其放在被定义的类或结构后面
```C++
class A {
public: 
	virtual void foo(){}
	virtual void bar() {}
	void foobar(){}
};
class B : public A {
public:
	void foo() override{}
	void bar() override final {};
	void foobar() override {};  // error 非虚函数不能override
};
class C final : public B {
public:
	void foo() override{}
	void bar() override{}	 // error final函数不可override
};
class D : public C {
	// final 类不可继承
};
```

## 对于lamda还有函数对象以及函数作为模板参数类型时的研究

```C++
template <typename T, typename F>
void func(T x, F f) {
	static int s = 1;
	cout << s << endl;
	s++;
	cout << "value" << f(x) << endl;
}

double funTest(double x) {
	return x * x;
}
double funTest2(double x) {
	return x * x;
}
double funTest3(double x) {
	return x * x;
}

struct fct {
	double operator()(double x) { return x * x; };
};

int main()
{
	double x = 10;
	func(x, funTest); 
	func(x, funTest2);
	func(x, funTest3); // all this use same static s
	func(x, fct()); // use unique static s
	func(x, [](double d)->double {  // use unique static s
		return d * d; });
}
```

# 10 是否应该返回对象

## F.20

在函数输出数值时，尽量使用返回值而非输出参数

## 一个简单的例子说明

```C++
// 调用者负责管理内存，接口负责生成

error_code_t add(
  matrix* result,
  const matrix& lhs,
  const matrix& rhs);
error_code_t multiply(
  matrix* result,
  const matrix& lhs,
  const matrix& rhs);
…
  error_code_t ec;
  …
  matrix temp;
  ec = multiply(&temp, a, b);
  if (ec != SUCCESS) {
    goto end;
  }
  matrix r;
  ec = add(&r, temp, c);
  if (ec != SUCCESS) {
    goto end;
  }
  …
end:
  // 返回 ec 或类似错误处理

// 接口负责对象的堆上生成和内存管理

matrix* add(
  const matrix* lhs,
  const matrix* rhs,
  error_code_t* ec);
matrix* multiply(
  const matrix* lhs,
  const matrix* rhs,
  error_code_t* ec);
void deinitialize(matrix** mat);
…
  error_code_t ec;
  …
  matrix* temp = nullptr;
  matrix* r = nullptr;
  temp = multiply(a, b, &ec);
  if (!temp) {
    goto end;
  }
  r = add(temp, c, &ec);
  if (!r) {
    goto end;
  }
  …
end:
  if (temp) {
    deinitialize(&temp);
  }
  // 返回 ec 或类似错误处理

// 接口直接返回对象

#include <armadillo>
#include <iostream>

using arma::imat22;
using std::cout;

int main()
{
  imat22 a{{1, 1}, {2, 2}};
  imat22 b{{1, 0}, {0, 1}};
  imat22 c{{2, 2}, {1, 1}};
  imat22 r = a * b + c;
  cout << r;
}
```

## 如何返回一个对象

一个用来返回的对象，通常应当是可移动构造 / 赋值的，一般也同时是可拷贝构造 / 赋值的。如果这样一个对象同时又可以默认构造，我们就称其为一个半正则（semiregular）的对象。如果可能的话，我们应当尽量让我们的类满足半正则这个要求。

返回非引用类型的表达式结果是个纯右值（prvalue）。在执行 auto r = … 的时候，编译器会认为我们实际是在构造 matrix r(…)，而“…”部分是一个纯右值。因此编译器会首先试图匹配 matrix(matrix&&)，在没有时则试图匹配 matrix(const matrix&)；也就是说，有移动支持时使用移动，没有移动支持时则拷贝。

## 返回值优化（拷贝消除）

```C++
class A {
public:
	A() { cout << "Create A\n"; }
	~A() { cout << "Destroy A\n"; }
	A(const A&) { cout << "Copy A\n"; }
	A(A&&) { cout << "Move A\n"; }
};

A getA_unnamed() 
{
	return A();
}

int main()
{
	auto a = getA_unnamed();
}
```
在完全关闭优化的情况下，输出也只有Create A和Destroy A
```
class A {
public:
	A() { cout << "Create A\n"; }
	~A() { cout << "Destroy A\n"; }
	A(const A&) { cout << "Copy A\n"; }
	A(A&&) { cout << "Move A\n"; }
};

A getA_unnamed() 
{
	A a;
	return a;
}

int main()
{
	auto a = getA_unnamed();
}
```
只有在MSVC上完全关闭优化，上面才会多产生一次Move A和Destroy A。
```C++
class A {
public:
	A() { cout << "Create A\n"; }
	~A() { cout << "Destroy A\n"; }
	A(const A&) { cout << "Copy A\n"; }
	A(A&&) { cout << "Move A\n"; }
};

A getA_unnamed() 
{
	A a1;
	A a2;
	if (rand() > 42) {
		return a1;
	}
	else {
		return  a2;
	}
	
}

int main()
{
	auto a = getA_unnamed();
}
```
这种情况下会有一次Move。如果把Move删除掉？原先的Move A变为了Copy A。如果继续删除Copy构造的话是不是就直接编译报错了呢？在使能C++17之后，能被返回值优化的场景下，不会报错。将对象直接构造在目标位置上

# 11 Unicode：进入多文字支持的世界

## 一些历史

- ASCII创立于1963年，用0-127代表常用的字符。非常简单
- 最早的中文字符是1980年国标GB2312，是一种于ASCII兼容的编码方式，单字节标示ASCII而双字节标示GB2312中的字符；GB2312扩展后就是GBK，是中文windows使用的标准编码
- Unicode统一编码：Unicode 的编码点是从 0x0 到 0x10FFFF，一共 1,114,112 个位置。一般用“U+”后面跟 16 进制的数值来表示一个 Unicode 字符，如 U+0020 表示空格，U+6C49 表示“汉”，U+1F600 表示“😀”，等等（不足四位的一般写四位）：

##Unicode

- UTF-32，编码点的直接映射；
- UTF-16，对于从 U+0000 到 U+FFFF 的字符，使用 16 比特的直接映射；对于大于 U+FFFF 的字符，使用 32 比特的特殊映射关系——在 Unicode 的 16 比特编码点中 0xD800–0xDFFF 是一段空隙，使得这种变长编码成为可能。在一个 UTF-16 的序列中，如果看到内容是 0xD800–0xDBFF，那这就是 32 比特编码的前 16 比特；如果看到内容是 0xDC00–0xDFFF，那这是 32 比特编码的后 16 比特；如果内容在 0xD800–0xDFFF 之外，那就是一个 16 比特的映射。
- UTF-，1 到 4 字节的变长编码。在一个合法的 UTF-8 的序列中，如果看到一个字节的最高位是 0，那就是一个单字节的 Unicode 字符；如果一个字节的最高两比特是 10，那这是一个 Unicode 字符在编码后的后续字节；否则，这就是一个 Unicode 字符在编码后的首字节，且最高位开始连续 1 的个数表示了这个字符按 UTF-8 的方式编码有几个字节
- 因此，Unicode 文本文件通常有一个使用 BOM（byte order mark）字符的约定，即字符 U+FEFF [11]。由于 Unicode 不使用 U+FFFE，在文件开头加一个 BOM 即可区分各种不同编码：在 UTF-8 编码下使用 BOM 字符并非必需，尤其在 Unix 上。但 Windows 上通常会使用 BOM 字符，以方便区分 UTF-8 和传统编码。

## 太难了  跳过

# 12 编译期多态：泛型编程和模板入门

## 面向对象和多态
```C++

class shape {
public:
  …
  virtual void draw(const position&) = 0;
};
```
上面的类定义意味着所有的子类必须实现 draw 函数，所以可以认为 shape 是定义了一个接口（按 Java 的概念）。在面向对象的设计里，接口抽象了一些基本的行为，实现类里则去具体实现这些功能。当我们有着接口类的指针或引用时，我们实际可以唤起具体的实现类里的逻辑.但这种面向对象的方式，并不是唯一一种实现多态的方式。在很多动态类型语言里，有所谓的“鸭子”类型---如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子.

虽然 C++ 的标准容器没有对象继承关系，但彼此之间有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++ 的模板，已经足够表达这些鸭子类型。

## C++模板
### 定义模板

```C++
int my_gcd(int a, int b)
{
  while (b != 0) {
    int r = a % b;
    a = b;
    b = r;
  }
  return a;
}


template <typename E>
E my_gcd(E a, E b)
{
  while (b != E(0)) {
    E r = a % b;
    a = b;
    b = r;
  }
  return a;
}
```
对于标准的 int、long、long long 等类型及其对应的无符号类型，以上代码都能正常工作，并能得到正确的结果。

### 实例化模板

编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。

### 特化模板

- 添加代码，让那个类型支持所需要的操作（对成员函数无效）。
```C++

cln::cl_I
operator%(const cln::cl_I& lhs,
          const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}

```
- 对于函数模板，可以直接针对那个类型进行重载。
```C++

template <typename E>
E my_gcd(E a, E b)
{
  while (b != E(0)) {
    E r = my_mod(a, b);
    a = b;
    b = r;
  }
  return a;
}

template <typename E>
E my_mod(const E& lhs,
         const E& rhs)
{
  return lhs % rhs;
}


cln::cl_I
my_mod(const cln::cl_I& lhs,
       const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}
```
- 对于类模板和函数模板，可以针对那个类型进行特化
```C++

template <>
cln::cl_I my_mod<cln::cl_I>(
  const cln::cl_I& lhs,
  const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}
```

展示特化的更好的例子是 C++11 之前的静态断言。使用特化技巧可以大致实现 static_assert 的功能
```C++
template <bool>
struct compile_time_error;
template <>
struct compile_time_error<true> {};


#define STATIC_ASSERT(Expr, Msg)   \
  {                                \
    compile_time_error<bool(Expr)> \
      ERROR_##_Msg;                \
    (void)ERROR_##_Msg;            \
  }
```
# 13 编译器能做些什么

## 编译器计算

```C++
template <int n>
struct factorial {
	static const int value =
		n * factorial<n - 1>::value;
};
template<>
struct factorial<0> {
	static const int value = 1;
};
int main()
{
	STATIC_ASSERT(3628800 == factorial<10>::value, "true")
		cout << factorial<10>::value;
}
```
带静态检查的版本
```C++
template <int n>
struct factorial {
	static_assert(n >= 0, "Arg must be non-nagative");
	static const int value =
		n * factorial<n - 1>::value;
};
template<>
struct factorial<0> {
	static const int value = 1;
};
```
编译器计算1...n累加，这个地方太难懂了.使用https://cppinsights.io/ 辅助下把。 这里有个细节：就是用 :: 取一个成员类型、并且 :: 左边有模板参数的话，得额外加上 typename 关键字来标明结果是一个类型。
```

template <bool cond,
	typename Then,
	typename Else>
	struct If;

template <typename Then,
	typename Else>
	struct If<true, Then, Else> {
	typedef Then type;
};

template <typename Then,
	typename Else>
	struct If<false, Then, Else>{
	typedef Else type;
};

template <bool condition,
	typename Body>
struct WhileLoop;

template <typename Body>
struct WhileLoop<true, Body>{
	typedef typename WhileLoop<
		Body::cond_value,
		typename Body::next_type>::type type;
};

template <typename Body>
struct WhileLoop<false, Body> {
	typedef typename Body::res_type type;
};

template <typename Body>
struct While {
	typedef typename WhileLoop<
		Body::cond_value, Body>::type type;
};


template <class T, T v>
struct my_integral_constant {
	static const T value = v;
	typedef T value_type;
	typedef my_integral_constant type;
};


template <int result, int n>
struct SumLoop {
	static const bool cond_value =
		n != 0;
	static const int res_value =
		result;
	typedef my_integral_constant<
		int, res_value>
		res_type;
	typedef SumLoop<result + n, n - 1>
		next_type;
};

template <int n>
struct Sum {
	typedef SumLoop<0, n> type;
};


int main()
{
	

	cout << While<Sum<10>::type>::type::value;
}
```

## 编译器类型推导

C++ 标准库在 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）[2]。和上一节给出的例子相似，这些特点既是类型，又是常值。类似上面，很多容器类里会有一个 destroy 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 true_type，要么是 false_type。像 is_trivially_destructible 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：
```C++

typedef std::integral_constant<
  bool, true> true_type;
typedef std::integral_constant<
  bool, false> false_type;
  
  
template <typename T>
class SomeContainer {
public:
  …
  static void destroy(T* ptr)
  {
    _destroy(ptr,
      is_trivially_destructible<
        T>());
  }

private:
  static void _destroy(T* ptr,
                       true_type)
  {}
  static void _destroy(T* ptr,
                       false_type)
  {
    ptr->~T();
  }
};
```
我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 remove_const 为例（用来去除类型里的 const 修饰）.如果对 const char* 应用 remove_const 的话，结果还是 const char*。原因是，const char* 是指向 const char 的指针，而不是指向 char 的 const 指针
```C++

template <class T>
struct remove_const {
  typedef T type;
};
template <class T>
struct remove_const<const T> {
  typedef T type;
};
```
## 简易写法
```C++
template <class T>
inline constexpr bool
  is_trivially_destructible_v =
    is_trivially_destructible<
      T>::value;
      

template <class T>
using remove_const_t =
  typename remove_const<T>::type;
```

## 通用的 fmap 函数模板

```C++
template <
template <typename, typename> class OutContainer = vector,
typename F, class R>
auto fmap(F&& f, R&& inputs)
{
	typedef decay_t<decltype(f(*inputs.begin()))> result_type;
	OutContainer<result_type, allocator<result_type>> result;
	for (auto&& item : inputs) {
		result.push_back(f(item));
	}
	return result;
}

int add_1(int x) { return x + 1; };
int main()
{
	

	vector<int> v{ 1,2,3,4,5 };
	
	auto result = fmap(add_1, v);
	result = fmap([](int x)->int {return x * x; }, result);
	cout << result;
}
```

## 总结

模板元编程的基本概念和例子，其本质是把计算过程用编译期的类型推导和类型匹配表达出来；然后介绍 type traits 及其基本用法；最后我们演示了一个简单的高阶函数 map


## 评论区

```txt
脑壳儿疼的兄弟姐妹们，我这有个小偏方， 哈哈

While< Sum<2>::type >::type::value 实例化(instantiation)过程
--> While< SumLoop<0, 2> >::type::value
--> WhileLoop<SumLoop<0, 2>::cond_value, SumLoop<0, 2>>::type::value
--> WhileLoop<true, SumLoop<0, 2>>::type::value

--> WhileLoop<SumLoop<0, 2>::cond_value, SumLoop<0, 2>::next_type>::type::value
--> WhileLoop<true, SumLoop<2, 1>>::type::value

--> WhileLoop<SumLoop<2, 1>::cond_value, SumLoop<2, 1>::next_type>::type::value
--> WhileLoop<true, SumLoop<3, 0>>::type::value

--> WhileLoop<SumLoop<3, 0>::cond_value, SumLoop<3, 0>::next_type>::type::value
--> WhileLoop<false, SumLoop<3, -1>>::type::value

--> SumLoop<3, -1>::res_type::value

-->integral_constant<int, 3>::value
-->3
```

```txt
这里有个小细节：const T& 等同于 T const&，但和 T& const 不同。前者是一个指向常量的引用，后者是一个常引用。只有后者才被看作是一个“常量”。
```

# 14 不是错误的替换失败时怎么回事

替换失败非错（substitution failure is not an error），英文简称为 SFINAE。

## 函数模板的重载决议
以下示例代码体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。

```C++

#include <stdio.h>

struct Test {
  typedef int foo;
};

template <typename T>
void f(typename T::foo)
{
  puts("1");
}

template <typename T>
void f(T)
{
  puts("2");
}

int main()
{
  f<Test>(10);
  f<int>(10);
}
```

## 编译期成员检测

快人们就发现 SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。下面这个模板，就可以检测一个类是否有一个名叫 reserve、参数类型为 size_t 的成员函数：
```

template <typename T>
struct has_reserve {
  struct good { char dummy; };
  struct bad { char dummy[2]; };
  template <class U,
            void (U::*)(size_t)>
  struct SFINAE {};
  template <class U>
  static good
  reserve(SFINAE<U, &U::reserve>*);
  template <class U>
  static bad reserve(...);
  static const bool value =
    sizeof(reserve<T>(nullptr))
    == sizeof(good);
};
```

## SFINAE 模板技巧

### enable_if

C++11 开始，标准库里有了一个叫 enable_if 的模板（定义在 里），可以用它来选择性地启用某个函数的重载。我们可以用 enable_if_t 来取到结果的类型。enable_if_t::value, void> 的意思可以理解成：如果类型 C 有 reserve 成员的话，那我们启用下面的成员函数，它的返回类型为 void。

```C++

template <typename C, typename T>
enable_if_t<has_reserve<C>::value,
            void>
append(C& container, T* ptr,
       size_t size)
{
  container.reserve(
    container.size() + size);
  for (size_t i = 0; i < size;
       ++i) {
    container.push_back(ptr[i]);
  }
}

template <typename C, typename T>
enable_if_t<!has_reserve<C>::value,
            void>
append(C& container, T* ptr,
       size_t size)
{
  for (size_t i = 0; i < size;
       ++i) {
    container.push_back(ptr[i]);
  }
}
```

### decltype 返回值
declval [4]，需要简单介绍一下。这个模板用来声明一个某个类型的参数，但这个参数只是用来参加模板的匹配，不允许实际使用。使用这个模板，我们可以在某类型没有默认构造函数的情况下，假想出一个该类的对象来进行类型推导。declval().reserve(1U) 用来测试 C& 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数
```

template <typename C, typename T>
auto append(C& container, T* ptr,
            size_t size)
  -> decltype(
    declval<C&>().reserve(1U),
    void())
{
  container.reserve(
    container.size() + size);
  for (size_t i = 0; i < size;
       ++i) {
    container.push_back(ptr[i]);
  }
}
```

### void_t 返回值

```

template <typename...>
using void_t = void;
```
这个类型模板会把任意类型映射到 void。它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。利用 decltype、declval 和模板特化，我们可以把 has_reserve 的定义大大简化：这里第二个 has_reserve 模板的定义实际上是一个偏特化 [6]。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个
```

template <typename T,
          typename = void_t<>>
struct has_reserve : false_type {};

template <typename T>
struct has_reserve<
  T, void_t<decltype(
       declval<T&>().reserve(1U))>>
  : true_type {};
```

### 标签分发 tag dispatch

```c++

template <typename C, typename T>
void _append(C& container, T* ptr,
             size_t size,
             true_type)
{
  container.reserve(
    container.size() + size);
  for (size_t i = 0; i < size;
       ++i) {
    container.push_back(ptr[i]);
  }
}

template <typename C, typename T>
void _append(C& container, T* ptr,
             size_t size,
             false_type)
{
  for (size_t i = 0; i < size;
       ++i) {
    container.push_back(ptr[i]);
  }
}

template <typename C, typename T>
void append(C& container, T* ptr,
            size_t size)
{
  _append(
    container, ptr, size,
    integral_constant<
      bool,
      has_reserve<C>::value>{});
}
```
另外，如果我们用 void_t 那个版本的 has_reserve 模板的话，由于模板的实例会继承 false_type 或 true_type 之一，代码可以进一步简化为：
```C++

template <typename C, typename T>
void append(C& container, T* ptr,
            size_t size)
{
  _append(
    container, ptr, size,
    has_reserve<C>{});
}
```

# constexp

## 初识constexp
存在两类 constexpr 对象：constexpr 变量（唉……😓）constexpr 函数一个 constexpr 变量是一个编译时完全确定的常数。一个 constexpr 函数至少对于某一组实参可以在编译期间产生一个编译期常数。下面的代码可以正常工作

```C++
constexpr int sqr(int n) { return n * n; }

int main()
{
	const int n = sqr(3);
	int a[n];
}
```

## constexpr 和编译期计算

使用编译期常量，就跟我们之前的那些类模板里的 static const int 变量一样，是可以进行编译期计算的。如果你在 main 里写 constexpr int n = factorial(-1); 的话，就会看到编译器报告抛出异常导致无法得到一个常量表达式
```C++
constexpr int factorial(int n)
{

  if (n < 0) {
    throw std::invalid_argument(
      "Arg must be non-negative");
  }
  
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}


int main()
{
  constexpr int n = factorial(10);
  printf("%d\n", n);
}
```

## constexpr 和 const

- const 的原本和基础的含义，自然是表示它修饰的内容不会变化.意 const 在类型声明的不同位置会产生不同的结果。对于常见的 const char* 这样的类型声明，意义和 char const* 相同，是指向常字符的指针，指针指向的内容不可更改；但和 char * const 不同，那代表指向字符的常指针，指针本身不可更改。本质上，const 用来表示一个运行时常量。
- constexpr用来做编译期常数

## 内联变量

允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，const 缺省是不内联的，而 constexpr 缺省就是内联的。这种区别在你用 & 去取一个 const int 值的地址、或将其传到一个形参类型为 const int& 的函数去的时候（这在 C++ 文档里的行话叫 ODR-use），就会体现出来。

```C++

#include <iostream>

struct magic {
  static const int number = 42;
};

int main()
{
  std::cout << magic::number
            << std::endl;
}
```

我们稍微改一点：就会产生编译问题
```C++

#include <iostream>
#include <vector>

struct magic {
  static const int number = 42;
};

int main()
{
  std::vector<int> v;
  // 调用 push_back(const T&)
  v.push_back(magic::number);
  std::cout << v[0] << std::endl;
}
```
说找不到 magic::number（注意：MSVC 缺省不报错，但使用标准模式——/Za 命令行选项——也会出现这个问题）。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：`const int magic::number = 42;`.必须正正好好一个，多了少了都不行，所以叫 one definition rule

修正这个问题的简单方法是把 magic 里的 static const 改成 static constexpr 或 static inline const。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 inline 关键字才会变成内联。

```C++
struct magic {
	static constexpr int number = 42;
};
int test1(const int n) { return n; }
int test2(const int& n) { return n + 1; }

int main()
{
	int a = magic::number;
	cout << magic::number;
	cout << test1(magic::number);

	cout << test2(magic::number);
}
```

## constexpr 变量模板

constexpr 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。由此，type traits 都获得了一种更简单的表示方式.这只是一个小小的语法糖，允许我们把 is_trivially_destructible::value 写成 is_trivially_destructible_v。
```C++
template <class T>
inline constexpr bool
  is_trivially_destructible_v =
    is_trivially_destructible<
      T>::value;
```

## constexpr 变量仍是 const

一个 constexpr 变量仍然是 const 常类型。需要注意的是，就像 const char* 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 const 也是不能缺少的：第二行里，constexpr 表示 b 是一个编译期常量，const 表示这个引用是常量引用。去掉这个 const 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报编译错误
```C++

constexpr int a = 42;
constexpr const int& b = a;
```
如果按照 const 位置的规则，constexpr const int& b 实际该写成 const int& constexpr b。不过，constexpr 不需要像 const 一样有复杂的组合，因此永远是写在类型前面的。

## constexpr 构造函数和字面类

一个合理的 constexpr 函数，应当至少对于某一组编译期常量的输入，能得到编译期常量的结果。为此，对这个函数也是有些限制的：如果一个类的构造函数里面只包含常量表达式、满足对 constexpr 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 constexpr 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等。

## if constexpr
在 C++17 里，我们只要在 if 后面加上 constexpr，代码就能工作了 [2]。当然，它要求括号里的条件是个编译期常量。满足这个条件后，标签分发、enable_if 那些技巧就不那么有用

```
如果一个类的构造函数里面只包含常量表达式、满足对 constexpr 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 constexpr 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等。
```

## output_container.h 解读

有点难度

# 函数对象和lambda：进入函数式编程

## C++98 的函数对象

函数对象（function object）[1] 自 C++98 开始就已经被标准化了。从概念上来说，函数对象是一个可以被当作函数来用的对象。它有时也会被叫做 functor，但这个术语在范畴论里有着完全不同的含义，还是不用为妙
```C++
struct adder {
	adder(int n):n_(n) {}
	int operator()(int x)const {
		return x + n_;
	}
private:
		int n_;
};
int main()
{
	auto add_2 = adder(2);
	adder add_3(3);
	cout << add_2(10) << add_3(10);
}

```

C++98 里也定义了少数高阶函数：你可以传递一个函数对象过去，结果得到一个新的函数对象。最典型的也许是目前已经从 C++17 标准里移除的 bind1st 和 bind2nd 了（在 头文件中提供）：
```
auto add_2 = bind2nd(plus<int>(), 2);
```
当然，auto 在 C++98 里是没有的，结果要赋给一个变量就有点别扭了，得写成：
```C++
binder2nd<plus<int> > add_2(
  plus<int>(), 2);
```
在 C++98 里我们通常会直接使用绑定的结果：
```
struct adder {
	adder(int n):n_(n) {}
	int operator()(int x)const {
		return x + n_;
	}
private:
		int n_;
};
int main()
{
	auto add_2 = adder(2);
	adder add_3(3);
	cout << add_2(10) << add_3(10);
	vector<int> v = { 1,2,3,4 };
	transform(v.begin(), v.end(), v.begin(), add_2);
	cout << v;
//	transform(v.begin(), v.end(), v.begin(), bind2nd(plus<int>(),2));
	cout << v;
}

```

## 函数的指针和引用

除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。
```C++
int add_22(int x) {
	return x + 2;
}
template <typename T>
auto test11(T fn) {
	return fn(2);
}

template <typename T>
auto test22(T& fn) {
	return fn(2);
}

template <typename T>
auto test33(T* fn) {
	return (*fn)(2);
}

template <typename T>
auto test44(T* fn) {
	return fn(2);
}
int main()
{
	cout << test11(add_22);
	cout << test22(add_22);
	cout << test33(add_22);
	cout << test44(add_22);
}
```

## Lambda 表达式

- 以一对中括号开始，中括号可以有内容
- 跟函数定义一样，有参数列表
- 跟正常函数一样 有函数体和return语句
- 一般不需要说明返回值；有特殊情况需要说明时 应该使用箭头语法 [](int x) -> int {...}
- 每个 lambda 表达式都有一个全局唯一的类型，要精确捕捉 lambda 表达式到一个变量中，只能通过 auto 声明的方式
```
	auto add_2 = [](int x) {
		return x + 2;
	};
	cout << add_2(100);
```
可以定义一个通用的adder
```
auto adder = [](int n) {
		return [n](int x) {
			return x + n;
		};
	};
	auto adder1 = adder(1);
	cout << adder1(100);
	cout << adder(1)(100);
```
不过，最常见的情况是，写匿名函数就是希望不需要起名字。以前面的把所有容器元素值加 2 的操作为例，使用匿名函数可以得到更简洁可读的代码：
```
	vector<int> v = { 1,2,3,4 };
	transform(v.begin(), v.end(), v.begin(),
		[](int x) {return x * x; });
	cout << v;
```
一个 lambda 表达式除了没有名字之外，还有一个特点是你可以立即进行求值。这就使得我们可以把一段独立的代码封装起来，达到更干净、表意的效果。
```
[](int x) { return x * x; }(3)
```
这个表达式的结果是 3 的平方 9。即使这个看似无聊的例子，都是有意义的，因为它免去了我们定义一个 constexpr 函数的必要。只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数。
另外一种用途是解决多重初始化路径的问题。假设你有这样的代码：
```C++

Obj obj;
switch (init_mode) {
case init_mode1:
  obj = Obj(…);
  break;
case init_mode2;
  obj = Obj(…);
  break;
…
}

```
有时候更直截了当的做法是用一个 lambda 表达式来进行改造，既可以提升性能（不需要默认函数或拷贝 / 移动），又让初始化部分显得更清晰：
```
auto obj = [init_mode]() {
  switch (init_mode) {
  case init_mode1:
    return Obj(…);
    break;
  case init_mode2:
    return Obj(…);
    break;
  …
  }
}();
```
## 变量捕获

变量捕获的开头是可选的默认捕获符 = 或 &，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：
- 本地变量名标明对其按值捕获（不能在默认捕获符 = 后出现；因其已自动按值捕获所有本地变量）
- & 加本地变量名标明对其按引用捕获（不能在默认捕获符 & 后出现；因其已自动按引用捕获所有本地变量）
- this 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 = 和 & 号可以自动捕获 this（并且在 C++20 之前，在 = 后写 this 会导致出错）
- \*this 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）

一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长，并在有下面需求之一时才使用：
- 需要在 lambda 表达式中修改这个变量并让外部观察到
- 需要看到这个变量在外部被修改的结果
- 这个变量的复制代价比较高

按引用捕获
```C++
vector<int> v = { 1,2,3,4 };
	[&](int n) {
		v.push_back(n);
	}(5);
	cout << v;
```
按值捕获外围对象
```
int get_count()
{
	static int count = 0;
	return ++count;
}
class task {
public:
	task(int data) : data_(data) {}
	auto lazy_launch()
	{
		return[*this, count = get_count()]()
			mutable {
			ostringstream oss;
			oss << "Done work " << data_
				<< "(No. " << count
				<< ") in thread  "
				<< this_thread::get_id()
				<< "add is " << &this << "\n";
			msg_ = oss.str();
			caculate();
		};
	}
	void caculate() {
		this_thread::sleep_for(100ms);
		cout << msg_;
	}
private:
	int data_;
	string msg_;
};
int main()
{
	auto t = task{ 37 };
	thread t1{ t.lazy_launch() };
	thread t2{ t.lazy_launch() };
	t1.join(); t2.join();
}
```
- mutable 标记使捕获的内容可更改（缺省不可更改捕获的值，相当于定义了 operator()(…) const）；
- [\*this] 按值捕获外围对象（task）；
- [count = get_count()] 捕获表达式可以在生成 lambda 表达式时计算并存储等号后表达式的结果。

## 泛型 lambda 表达式

函数的返回值可以 auto，但参数还是要一一声明的。在 lambda 表达式里则更进一步，在参数声明时就可以使用 auto（包括 auto&& 等形式）。不过，它的功能也不那么神秘，就是给你自动声明了模板而已。毕竟，在 lambda 表达式的定义过程中是没法写 template 关键字的。

```C++

template <typename T1,
          typename T2>
auto sum(T1 x, T2 y)
{
  return x + y;
}
```
跟他等价的lamda表达式如下，写法更加简单
```C++

auto sum = [](auto x, auto y)
{
  return x + y;
}
```
这么写有什么用呢？简单来说，答案是可组合性
```C++
	array a{ 1,2,3,4,5 };
	auto s = accumulate(a.begin(), a.end(), 0, [](auto x, auto y) {
		return x + y;
		});
	cout << s;
	s = accumulate(a.begin(), a.end(), 1, [](auto x, auto y) {
		return x * y;
		});
	cout << "\n";
	cout << s;
```

## bind 模板

bind1st 和 bind2nd 目前已经从 C++ 标准里移除。原因实际上有两个：它的功能可以被 lambda 表达式替代有了一个更强大的 bind 模板.在 C++14 之后的年代里，已经没有什么地方必须要使用 bind 了。

## function 模板

每一个 lambda 表达式都是一个单独的类型，所以只能使用 auto 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 function 模板 。function 模板的参数就是函数的类型，一个函数对象放到 function 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 function 对象的创建还是比较耗资源的，所以请你只在用 auto 等方法解决不了问题的时候使用这个模板。
```C++

map<string, function<int(int, int)>>
  op_dict{
    {"+",
     [](int x, int y) {
       return x + y;
     }},
    {"-",
     [](int x, int y) {
       return x - y;
     }},
    {"*",
     [](int x, int y) {
       return x * y;
     }},
    {"/",
     [](int x, int y) {
       return x / y;
     }},
  };
```
