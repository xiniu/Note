# 开篇词 C++这么难，为什么我们还要用C++？

## C++是一门多范式的通用编程语言

- 支持面向过程编程
- 支持面向对象编程
- 支持泛型编程
- 新版本还支持函数式编程

## 一些著名的用到C++的场景

- 大型桌面应用程序（Adobe Photoshop、Google Chrome和Microsoft Office）
- 大型网站后台（如Google的搜索引擎）
- 游戏和游戏引擎（Unity）
- 编译器（LLVM/Clang和GCC）
- 解释器（如Java虚拟机和V8 JavaScript引擎）
- 实时控制（战斗机的飞行控制、火星车的自动驾驶系统）
- 视觉和智能引擎（OpenCV、TensorFlow）
- 数据库（MicroSo SQL Server、 MySql、MongoDB）

## C++的竞争力

- 抽象能力：抽象能力代表着更高的开发效率；更为重要的是，不会因此而降低性能
- 性能：快且占用资源少
- 功耗：更性能相关，性能好了功耗自然低

## 什么时候该用C++

只需要回答一个问题：你在开发上付出的额外时间，能从性能上省回来吗？----C++需要的代码行数一般是Python的三倍左右，而性能可以达到Python的十倍以上。C++是解决性能问题的利器

# 课前必读 有关术语发音及环境要求

## 几个术语

| 英文 | 含义 |
| :--- | :---- |
| decltype |  |
| declval  |  |
| SFINAE   |  |

## 环境要求

大部分时间不会使用超过C++17标准的语言特性。
- 使用GCC的话，推荐使用下面的命令行
```
g++ -std=c++17 -W -Wall -Wfatal-errors filename
```
- 使用MSVC的话：
```
cl /std:c++17 /EHsc /W3 filename
```

# 01 堆、栈、RAII：C++里应该如何管理资源

## 基本概念：

- 堆（heap），在内存管理语境下，指的是同台分配的内存区域（跟数据结构中的堆不是一回事）。这里的内存使用后需要手工释放，否则造成内存泄漏。
- 自由存储区（free store），特指使用new和delete来分配和释放的内存区域，一般而言是堆的子集（new/delete---> free store;  malloc/free--->heap）
- 栈（stack），在内存管理预警下指的是函数调用过程中产生的本地变量和调用数据的区域（跟数据结构的栈高度相似，满足 last-in-first-out--->LIFO）
- RAII（Resource Acquisition Is Initialzation），C++特有的资源管理方式，C++是唯一一个依赖RAII来做资源管理的。RAII依赖栈和析构函数，来对所有资源进行管理

## 堆

使用堆或者说使用动态内存分配，是一件再自然不过的事情

- C++里的new和malloc导致在堆上分配内存（并构造对象）
```
auto ptr = new std::vector<int>();
```
- 历史上看，动态分配内存实际出现较晚。因为动态分配内存带来不确定性：
  - 耗时需要多久
  - 失败了怎么办
  - 至今仍然有很多场合禁用动态内存，例如飞行控制器和电信设备
  
 - 三个基本的内存管理器操作（C++一般只12，Java做13，而Python做123）：
  - 1让内存管理器分配一个某个大下的内存块
  - 2让内存管理器释放一个之前分配的内存块
  - 3让内存管理器做垃圾回收，寻找不再使用的内存并释放 
  - 以上三个内存管理器基本操作都不简单，且彼此之间关联
    - 分配内存要考虑程序当前有多少未分配内存，内存不足时要从操作系统申请新的内存；内存充足时要从可用内存取一块合适大小的内存，做簿记工作标为已用，将内存返回给请求内存的代码
    - 释放内存不只是简单的将内存标记为未使用，对于连续未使用的内存块，需要将其合并，以便满足后续较大的内存分配要求
    - 垃圾回收有很多不同的策略和实现方式。C++通常都不适用垃圾回收
    
大部分软件开发人员不需要担心这些问题。内存分配和释放的管理，是内存管理器的任务，不需要我们介入。我么只需要正确的使用new和delete。我们只需要正确的使用new和delete，每个new出来的对象都应该用delete释放。但这也并不简单。漏掉delele是一种常见的情况，叫内存泄漏。一个简单例子：
```
void foo()
{
    bar* ptr = new bar();
    ...
    delete bar;
}
```
以上代码的两个问题：
- 中间省略的代码有可能会抛出异常，大致最红的delete ptr无法执行
- 不符合C++的惯用法，C++中这种情况下99%的可能性不应该使用堆内存分配，而应该使用栈内存分配。

更常见更合理的情况是分配和内存不在一个函数里，这样的话漏delete的可能性更大了
```
bar* make_bar(...)
{
    bar* ptr = nullptr;
    try {
        ptr = new bar();
        ...
    }
    catch(...) {
        delete ptr;
        throw;
    }
    return ptr;
}

void foo()
{
    ...
    bar* ptr = make_bar(...);
    ...
    delete ptr;
}
```

## 栈

在包括x86在内的大部分计算机体系结构中，栈的增长方向是低地址。任何一个函数，进入后只能使用进入函数时栈指针向上部分的栈空间。当调用另外一个函数时，也会把参数压入栈（忽略寄存器传参数的情况），然后把系一行汇编指令的地址入栈，并跳转至新的函数。新的函数进入后，首先做一些必须的保存工作，然后调整栈指针，分配出本地变量所需的空间，然后执行代码；执行完毕后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。某个函数占用的栈空间，有个特定的术语叫栈帧（stack frame）

本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起啊；函数执行完成后，这些内存就自然而然的释放掉了。
- 栈上的分配极为简单，移动栈指针而已
- 释放也极为简单，移动栈指针而已
- 后进先出，不可能出现内存随便

对于有构造和析构函数的非POD（Plain Old Data）类型，栈上的内存分配也同样有效，C++编译器会在合适的位置插入构造和析构函数的调用。**编译器会自动调用析构函数，包括函数执行发生异常的情况，在发生异常时对于析构函数的调用，叫栈展开（stack unwind）**
```
#include<cstdio>
class Obj
{
public:
    Obj() 
    {
        puts("Obj()");
    }
    ~Obj()
    {
        puts("~Obj()");
    }
};

void foo(int n)
{
    Obj obj;
    if (42 == n)
    {
        throw "life, universe and everything";
    }
}
int main()
{
    try {
        foo(41);
        foo(42);
    }
    catch(const char* s)
    {
        puts(s);
    }
}
```
执行结果：注意顺序，如果有异常，在catch之前，栈上的对象就会析构
```
Obj()
~Obj()
Obj()
~Obj()
life, universe and everything
```
在C++里所有的变量缺省都是值语义，跟Java或这Python引用堆上的对象不一样。对于智能指针，ptr->call()和ptr.get()语法上都是对的。值语义和引用语义是C++的特点，也是复杂性的来源

## RAII

C++支持将对象存储在栈上，但是很多情况下不能或者不应该存储在栈上：
- 对象很大
- 对象的大小在编译时不能确定
- 对象是函数的返回值，但是由于某些愿意按，不能使用对象的值返回。

一种常见的情况的，在工厂方法或者面向对象编程的情况下，返回值的类型是基类指针（返回值只能是基类指针，而无法是基类值，否则会发生对象切片，但并不会导致编译错误）.这样该如何保证不会出现内存泄漏呢？
```
enum class shape_type {
    circle,
    triangle,
    rectangle
};

class shape
{
public:
    shape() { puts("shape created"); }
    virtual ~shape() { (puts("shape decreated")); }
    virtual void tell() = 0;
};

class circle : public shape
{
public:
    circle() { puts("circle created"); }
    ~circle() { puts("circulr decreated"); }
    void tell() { puts("I'am circle"); }
};

class triangle : public shape
{
public:
    triangle() { puts("triangle created"); }
    ~triangle() { puts("triangle decreated"); }
    void tell() { puts("I'am triangle"); }
};

class rectangle : public shape
{
public:
    rectangle() { puts("rectangle created"); }
    ~rectangle() { puts("rectangle decreated"); }
    void tell() { puts("I'am rectangle"); }
};

shape* create_shape(shape_type type)
{
    switch (type)
    {
    case shape_type::circle:
        return new circle();
    case shape_type::triangle:
        return new triangle();
    case shape_type::rectangle:
        return new rectangle();
    default:
        puts("invalid type");
        return nullptr;
    }
}

int main()
{
    shape* aRectangle = create_shape(shape_type::rectangle);
    aRectangle->tell();
    delete aRectangle; // if missed this, then memory leak
}
```
上述代码的结果如下，同时也用于说明虚函数动态绑定
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
我们怎么才能确保，在使用create_shape的返回值时不会发生内存泄漏么？答案就是析构函数以及栈展开行为。我们只需要把返回值放到一个本地变量，并确认其析构函数会删除该对象。一个简单的实现如下所示：
```
class shape_wrapper
{
public:
    explicit shape_wrapper(
        shape* ptr = nullptr)
        : ptr_(ptr) {}
    ~shape_wrapper() { delete ptr_; }
    shape* get() const { return ptr_; }
private:
    shape* ptr_;

};


int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    shape_wrapper ptr_wrapper(
        create_shape(shape_type::rectangle)
    );
    ptr_wrapper.get()->tell();

}
```
输出如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
在new一个对象和delete指针时编译器需要干的活，大致可用如下翻译：new的时候先分配内存，失败时整个操作失败向外抛出异常（bad_alloc），然后在这个结果指针上构造对象，构造成功则整体完成，否则失望内存并向外抛出异常；delete则判断是否为空，不空则调用析构函数并释放内存。
```
// new circle()
{
    void* temp =  operator new(sizeof(circle));
    try {
        circle* ptr = 
            static_cast<circle*>(temp);
        ptr->circle();
        return ptr;
    }
    catch(...) {
        operator delete(ptr);
        throw;
    }
}

// delete ptr
{
    if (ptr != nullptr) {
        ptr->~shape();
        operator delete(ptr);
    }
}
```
回到shape_wrapper和他的析构行为，在**析构函数里做必要的清理工作**，这就是RAII的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（fstream的析构函数就是这么做的）
- 释放同步锁
- 释放其他重要的系统资源

例如我们应该使用：
```
std::mutex mtx;
void some_func()
{
    std::lock_guard<std::mutex> guard(mtx);
    // do something
}
```
而不是
```
std::mutex mtx;
void some_func()
{
    mtx.lock();
    // If exception occure, unlock will not be called
    mtx.unlock();
}
```


## 内容小结

栈是C++里最自然的内存使用方式，基于栈和析构函数的RAII机制，可以有效的对包括堆内存在内的系统资源进行统一管理

## 课后思考 

shape_wrapper和智能指针比起来，还缺少那些功能？ 引用计数/拷贝和移动等

# 02 自己动手，实现C++的智能指针

智能指针本质上并不神秘，就是RAII资源管理功能的自然展现

## 回顾

上一讲的这个类，可以完成智能指针最基本的功能，对超出作用域的对象进行释放，但缺少：
- 这个类只适用于shape类
- 该对象的行为不够像指针
- 拷贝该类对象会引发程序行为异常
逐一弥补这些问题。

## 模板化和易用性

要让这个类能够包装任意类型的指针，需要把他变为一个类模板，模板本身不是特别复杂的特性
```
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
private:
    T* ptr_;

};
```

另外，需要将其改造，使其行为和指针类似：
- 使用\*运算符解引用
- 使用->指向对象成员
- 和指针一样用在布尔表达式中
添加几个成员函数即可，这里的运算符重载比较奇怪，之前没接触过->和bool()重载
```
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    if (ptr_smart)
    {
        puts("That's good!");
    }
}
```

结果如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
called bool()
That's good!
rectangle decreated
shape decreated
```

## 拷贝构造和赋值

考虑对于上面的smart_ptr的拷贝行为，如果使用默认的拷贝方法，可能会导致core（对同一块地址释放两次，通常会导致程序奔溃）。
最简单的情况就是禁止拷贝.简单却有效。
```
template <typename T>
class smart_ptr {
  …
  smart_ptr(const smart_ptr&)
    = delete;
  smart_ptr& operator=(const smart_ptr&)
    = delete;
  …
};
```
是不是可以考虑在拷贝时进行深拷贝？
- 通常不会这么做，使用智能指针就是要减少对象拷贝
- 没有办法，只有指针，没有通用的版本可以通过基类指针构造出一个子类对象来








