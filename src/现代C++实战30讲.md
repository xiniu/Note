# 开篇词 C++这么难，为什么我们还要用C++？

## C++是一门多范式的通用编程语言

- 支持面向过程编程
- 支持面向对象编程
- 支持泛型编程
- 新版本还支持函数式编程

## 一些著名的用到C++的场景

- 大型桌面应用程序（Adobe Photoshop、Google Chrome和Microsoft Office）
- 大型网站后台（如Google的搜索引擎）
- 游戏和游戏引擎（Unity）
- 编译器（LLVM/Clang和GCC）
- 解释器（如Java虚拟机和V8 JavaScript引擎）
- 实时控制（战斗机的飞行控制、火星车的自动驾驶系统）
- 视觉和智能引擎（OpenCV、TensorFlow）
- 数据库（MicroSo SQL Server、 MySql、MongoDB）

## C++的竞争力

- 抽象能力：抽象能力代表着更高的开发效率；更为重要的是，不会因此而降低性能
- 性能：快且占用资源少
- 功耗：更性能相关，性能好了功耗自然低

## 什么时候该用C++

只需要回答一个问题：你在开发上付出的额外时间，能从性能上省回来吗？----C++需要的代码行数一般是Python的三倍左右，而性能可以达到Python的十倍以上。C++是解决性能问题的利器

# 课前必读 有关术语发音及环境要求

## 几个术语

| 英文 | 含义 |
| :--- | :---- |
| decltype |  |
| declval  |  |
| SFINAE   |  |

## 环境要求

大部分时间不会使用超过C++17标准的语言特性。
- 使用GCC的话，推荐使用下面的命令行
```
g++ -std=c++17 -W -Wall -Wfatal-errors filename
```
- 使用MSVC的话：
```
cl /std:c++17 /EHsc /W3 filename
```

# 堆、栈、RAII：C++里应该如何管理资源

## 基本概念：

- 堆（heap），在内存管理语境下，指的是同台分配的内存区域（跟数据结构中的堆不是一回事）。这里的内存使用后需要手工释放，否则造成内存泄漏。
- 自由存储区（free store），特指使用new和delete来分配和释放的内存区域，一般而言是堆的子集（new/delete---> free store;  malloc/free--->heap）
- 栈（stack），在内存管理预警下指的是函数调用过程中产生的本地变量和调用数据的区域（跟数据结构的栈高度相似，满足 last-in-first-out--->LIFO）
- RAII（Resource Acquisition Is Initialzation），C++特有的资源管理方式，C++是唯一一个依赖RAII来做资源管理的。RAII依赖栈和析构函数，来对所有资源进行管理

## 堆

使用堆或者说使用动态内存分配，是一件再自然不过的事情

- C++里的new和malloc导致在堆上分配内存（并构造对象）
```
auto ptr = new std::vector<int>();
```
- 历史上看，动态分配内存实际出现较晚。因为动态分配内存带来不确定性：
  - 耗时需要多久
  - 失败了怎么办
  - 至今仍然有很多场合禁用动态内存，例如飞行控制器和电信设备
  
 - 三个基本的内存管理器操作（C++一般只12，Java做13，而Python做123）：
  - 1让内存管理器分配一个某个大下的内存块
  - 2让内存管理器释放一个之前分配的内存块
  - 3让内存管理器做垃圾回收，寻找不再使用的内存并释放 
  - 以上三个内存管理器基本操作都不简单，且彼此之间关联
    - 分配内存要考虑程序当前有多少未分配内存，内存不足时要从操作系统申请新的内存；内存充足时要从可用内存取一块合适大小的内存，做簿记工作标为已用，将内存返回给请求内存的代码
    - 释放内存不只是简单的将内存标记为未使用，对于连续未使用的内存块，需要将其合并，以便满足后续较大的内存分配要求
    - 垃圾回收有很多不同的策略和实现方式。C++通常都不适用垃圾回收
    
大部分软件开发人员不需要担心这些问题。内存分配和释放的管理，是内存管理器的任务，不需要我们介入。我么只需要正确的使用new和delete。我们只需要正确的使用new和delete，每个new出来的对象都应该用delete释放。但这也并不简单。漏掉delele是一种常见的情况，叫内存泄漏。一个简单例子：
```
void foo()
{
    bar* ptr = new bar();
    ...
    delete bar;
}
```
以上代码的两个问题：
- 中间省略的代码有可能会抛出异常，大致最红的delete ptr无法执行
- 不符合C++的惯用法，C++中这种情况下99%的可能性不应该使用堆内存分配，而应该使用栈内存分配。

更常见更合理的情况是分配和内存不在一个函数里，这样的话漏delete的可能性更大了
```
bar* make_bar(...)
{
    bar* ptr = nullptr;
    try {
        ptr = new bar();
        ...
    }
    catch(...) {
        delete ptr;
        throw;
    }
    return ptr;
}

void foo()
{
    ...
    bar* ptr = make_bar(...);
    ...
    delete ptr;
}
```

    















