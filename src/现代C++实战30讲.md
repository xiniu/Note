# 开篇词 C++这么难，为什么我们还要用C++？

## C++是一门多范式的通用编程语言

- 支持面向过程编程
- 支持面向对象编程
- 支持泛型编程
- 新版本还支持函数式编程

## 一些著名的用到C++的场景

- 大型桌面应用程序（Adobe Photoshop、Google Chrome和Microsoft Office）
- 大型网站后台（如Google的搜索引擎）
- 游戏和游戏引擎（Unity）
- 编译器（LLVM/Clang和GCC）
- 解释器（如Java虚拟机和V8 JavaScript引擎）
- 实时控制（战斗机的飞行控制、火星车的自动驾驶系统）
- 视觉和智能引擎（OpenCV、TensorFlow）
- 数据库（MicroSo SQL Server、 MySql、MongoDB）

## C++的竞争力

- 抽象能力：抽象能力代表着更高的开发效率；更为重要的是，不会因此而降低性能
- 性能：快且占用资源少
- 功耗：更性能相关，性能好了功耗自然低

## 什么时候该用C++

只需要回答一个问题：你在开发上付出的额外时间，能从性能上省回来吗？----C++需要的代码行数一般是Python的三倍左右，而性能可以达到Python的十倍以上。C++是解决性能问题的利器

# 课前必读 有关术语发音及环境要求

## 几个术语

| 英文 | 含义 |
| :--- | :---- |
| decltype |  |
| declval  |  |
| SFINAE   |  |

## 环境要求

大部分时间不会使用超过C++17标准的语言特性。
- 使用GCC的话，推荐使用下面的命令行
```
g++ -std=c++17 -W -Wall -Wfatal-errors filename
```
- 使用MSVC的话：
```
cl /std:c++17 /EHsc /W3 filename
```

# 01 堆、栈、RAII：C++里应该如何管理资源

## 基本概念：

- 堆（heap），在内存管理语境下，指的是同台分配的内存区域（跟数据结构中的堆不是一回事）。这里的内存使用后需要手工释放，否则造成内存泄漏。
- 自由存储区（free store），特指使用new和delete来分配和释放的内存区域，一般而言是堆的子集（new/delete---> free store;  malloc/free--->heap）
- 栈（stack），在内存管理预警下指的是函数调用过程中产生的本地变量和调用数据的区域（跟数据结构的栈高度相似，满足 last-in-first-out--->LIFO）
- RAII（Resource Acquisition Is Initialzation），C++特有的资源管理方式，C++是唯一一个依赖RAII来做资源管理的。RAII依赖栈和析构函数，来对所有资源进行管理

## 堆

使用堆或者说使用动态内存分配，是一件再自然不过的事情

- C++里的new和malloc导致在堆上分配内存（并构造对象）
```
auto ptr = new std::vector<int>();
```
- 历史上看，动态分配内存实际出现较晚。因为动态分配内存带来不确定性：
  - 耗时需要多久
  - 失败了怎么办
  - 至今仍然有很多场合禁用动态内存，例如飞行控制器和电信设备
  
 - 三个基本的内存管理器操作（C++一般只12，Java做13，而Python做123）：
  - 1让内存管理器分配一个某个大下的内存块
  - 2让内存管理器释放一个之前分配的内存块
  - 3让内存管理器做垃圾回收，寻找不再使用的内存并释放 
  - 以上三个内存管理器基本操作都不简单，且彼此之间关联
    - 分配内存要考虑程序当前有多少未分配内存，内存不足时要从操作系统申请新的内存；内存充足时要从可用内存取一块合适大小的内存，做簿记工作标为已用，将内存返回给请求内存的代码
    - 释放内存不只是简单的将内存标记为未使用，对于连续未使用的内存块，需要将其合并，以便满足后续较大的内存分配要求
    - 垃圾回收有很多不同的策略和实现方式。C++通常都不适用垃圾回收
    
大部分软件开发人员不需要担心这些问题。内存分配和释放的管理，是内存管理器的任务，不需要我们介入。我么只需要正确的使用new和delete。我们只需要正确的使用new和delete，每个new出来的对象都应该用delete释放。但这也并不简单。漏掉delele是一种常见的情况，叫内存泄漏。一个简单例子：
```c++
void foo()
{
    bar* ptr = new bar();
    ...
    delete bar;
}
```
以上代码的两个问题：
- 中间省略的代码有可能会抛出异常，大致最红的delete ptr无法执行
- 不符合C++的惯用法，C++中这种情况下99%的可能性不应该使用堆内存分配，而应该使用栈内存分配。

更常见更合理的情况是分配和内存不在一个函数里，这样的话漏delete的可能性更大了
```c++
bar* make_bar(...)
{
    bar* ptr = nullptr;
    try {
        ptr = new bar();
        ...
    }
    catch(...) {
        delete ptr;
        throw;
    }
    return ptr;
}

void foo()
{
    ...
    bar* ptr = make_bar(...);
    ...
    delete ptr;
}
```

## 栈

在包括x86在内的大部分计算机体系结构中，栈的增长方向是低地址。任何一个函数，进入后只能使用进入函数时栈指针向上部分的栈空间。当调用另外一个函数时，也会把参数压入栈（忽略寄存器传参数的情况），然后把系一行汇编指令的地址入栈，并跳转至新的函数。新的函数进入后，首先做一些必须的保存工作，然后调整栈指针，分配出本地变量所需的空间，然后执行代码；执行完毕后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。某个函数占用的栈空间，有个特定的术语叫栈帧（stack frame）

本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起啊；函数执行完成后，这些内存就自然而然的释放掉了。
- 栈上的分配极为简单，移动栈指针而已
- 释放也极为简单，移动栈指针而已
- 后进先出，不可能出现内存随便

对于有构造和析构函数的非POD（Plain Old Data）类型，栈上的内存分配也同样有效，C++编译器会在合适的位置插入构造和析构函数的调用。**编译器会自动调用析构函数，包括函数执行发生异常的情况，在发生异常时对于析构函数的调用，叫栈展开（stack unwind）**
```c++
#include<cstdio>
class Obj
{
public:
    Obj() 
    {
        puts("Obj()");
    }
    ~Obj()
    {
        puts("~Obj()");
    }
};

void foo(int n)
{
    Obj obj;
    if (42 == n)
    {
        throw "life, universe and everything";
    }
}
int main()
{
    try {
        foo(41);
        foo(42);
    }
    catch(const char* s)
    {
        puts(s);
    }
}
```
执行结果：注意顺序，如果有异常，在catch之前，栈上的对象就会析构
```
Obj()
~Obj()
Obj()
~Obj()
life, universe and everything
```
在C++里所有的变量缺省都是值语义，跟Java或这Python引用堆上的对象不一样。对于智能指针，ptr->call()和ptr.get()语法上都是对的。值语义和引用语义是C++的特点，也是复杂性的来源

## RAII

C++支持将对象存储在栈上，但是很多情况下不能或者不应该存储在栈上：
- 对象很大
- 对象的大小在编译时不能确定
- 对象是函数的返回值，但是由于某些愿意按，不能使用对象的值返回。

一种常见的情况的，在工厂方法或者面向对象编程的情况下，返回值的类型是基类指针（返回值只能是基类指针，而无法是基类值，否则会发生对象切片，但并不会导致编译错误）.这样该如何保证不会出现内存泄漏呢？
```c++
enum class shape_type {
    circle,
    triangle,
    rectangle
};

class shape
{
public:
    shape() { puts("shape created"); }
    virtual ~shape() { (puts("shape decreated")); }
    virtual void tell() = 0;
};

class circle : public shape
{
public:
    circle() { puts("circle created"); }
    ~circle() { puts("circulr decreated"); }
    void tell() { puts("I'am circle"); }
};

class triangle : public shape
{
public:
    triangle() { puts("triangle created"); }
    ~triangle() { puts("triangle decreated"); }
    void tell() { puts("I'am triangle"); }
};

class rectangle : public shape
{
public:
    rectangle() { puts("rectangle created"); }
    ~rectangle() { puts("rectangle decreated"); }
    void tell() { puts("I'am rectangle"); }
};

shape* create_shape(shape_type type)
{
    switch (type)
    {
    case shape_type::circle:
        return new circle();
    case shape_type::triangle:
        return new triangle();
    case shape_type::rectangle:
        return new rectangle();
    default:
        puts("invalid type");
        return nullptr;
    }
}

int main()
{
    shape* aRectangle = create_shape(shape_type::rectangle);
    aRectangle->tell();
    delete aRectangle; // if missed this, then memory leak
}
```
上述代码的结果如下，同时也用于说明虚函数动态绑定
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
我们怎么才能确保，在使用create_shape的返回值时不会发生内存泄漏么？答案就是析构函数以及栈展开行为。我们只需要把返回值放到一个本地变量，并确认其析构函数会删除该对象。一个简单的实现如下所示：
```c++
class shape_wrapper
{
public:
    explicit shape_wrapper(
        shape* ptr = nullptr)
        : ptr_(ptr) {}
    ~shape_wrapper() { delete ptr_; }
    shape* get() const { return ptr_; }
private:
    shape* ptr_;

};


int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    shape_wrapper ptr_wrapper(
        create_shape(shape_type::rectangle)
    );
    ptr_wrapper.get()->tell();

}
```
输出如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
```
在new一个对象和delete指针时编译器需要干的活，大致可用如下翻译：new的时候先分配内存，失败时整个操作失败向外抛出异常（bad_alloc），然后在这个结果指针上构造对象，构造成功则整体完成，否则失望内存并向外抛出异常；delete则判断是否为空，不空则调用析构函数并释放内存。
```c++
// new circle()
{
    void* temp =  operator new(sizeof(circle));
    try {
        circle* ptr = 
            static_cast<circle*>(temp);
        ptr->circle();
        return ptr;
    }
    catch(...) {
        operator delete(ptr);
        throw;
    }
}

// delete ptr
{
    if (ptr != nullptr) {
        ptr->~shape();
        operator delete(ptr);
    }
}
```
回到shape_wrapper和他的析构行为，在**析构函数里做必要的清理工作**，这就是RAII的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（fstream的析构函数就是这么做的）
- 释放同步锁
- 释放其他重要的系统资源

例如我们应该使用：
```c++
std::mutex mtx;
void some_func()
{
    std::lock_guard<std::mutex> guard(mtx);
    // do something
}
```
而不是
```c++
std::mutex mtx;
void some_func()
{
    mtx.lock();
    // If exception occure, unlock will not be called
    mtx.unlock();
}
```


## 内容小结

栈是C++里最自然的内存使用方式，基于栈和析构函数的RAII机制，可以有效的对包括堆内存在内的系统资源进行统一管理

## 课后思考 

shape_wrapper和智能指针比起来，还缺少那些功能？ 引用计数/拷贝和移动等

# 02 自己动手，实现C++的智能指针

智能指针本质上并不神秘，就是RAII资源管理功能的自然展现

## 回顾

上一讲的这个类，可以完成智能指针最基本的功能，对超出作用域的对象进行释放，但缺少：
- 这个类只适用于shape类
- 该对象的行为不够像指针
- 拷贝该类对象会引发程序行为异常
逐一弥补这些问题。

## 模板化和易用性

要让这个类能够包装任意类型的指针，需要把他变为一个类模板，模板本身不是特别复杂的特性
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
private:
    T* ptr_;

};
```

另外，需要将其改造，使其行为和指针类似：
- 使用\*运算符解引用
- 使用->指向对象成员
- 和指针一样用在布尔表达式中
添加几个成员函数即可，这里的运算符重载比较奇怪，之前没接触过->和bool()重载
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    if (ptr_smart)
    {
        puts("That's good!");
    }
}
```

结果如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
called bool()
That's good!
rectangle decreated
shape decreated
```

## 拷贝构造和赋值

考虑对于上面的smart_ptr的拷贝行为，如果使用默认的拷贝方法，可能会导致core（对同一块地址释放两次，通常会导致程序奔溃）。
最简单的情况就是禁止拷贝.简单却有效。
```c++
template <typename T>
class smart_ptr {
  …
  smart_ptr(const smart_ptr&)
    = delete;
  smart_ptr& operator=(const smart_ptr&)
    = delete;
  …
};
```
- 是不是可以考虑在拷贝时进行深拷贝？
    - 通常不会这么做，使用智能指针就是要减少对象拷贝
    - 没有办法，只有指针，没有通用的版本可以通过基类指针构造出一个子类对象来
- 试试在拷贝时转移指针的所有权:在拷贝构造函数中，通过release来释放other的指针所有权；在复制构造中，则通过拷贝
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }

    smart_ptr(smart_ptr& other) { puts("copy ctt called"); ptr_ = other.release(); }
    smart_ptr& operator=(smart_ptr& rhs) { puts("assign ctt called"); smart_ptr(rhs).swap(*this); return *this; }
    T* release() { T* ptr = ptr_; ptr_ = nullptr; return ptr; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    auto ptr_smart2 = ptr_smart;   // it called copy constractor only!!!
    if (ptr_smart)
    {
        puts("That's good!");
    }
    else {
        puts("ptr_smart has been released");
    }
    ptr_smart = ptr_smart2;
}
```
结果如下,注意，并不是说有=出现就是赋值构造。另外，有些赋值构造会写`if (this != &rhs)`，这种写法更罗嗦且异常性不够，如果赋值过程发生异常，this对象的内容可能已经破坏，上面这种代码的惯用法保证了**异常安全性：赋值分为拷贝和交换两部，拷贝发生异常，this对象不受任何影响，只存在赋值成功或者没有效果两种状态（swap-idom）**。以上其实是C++98的auto_ptr的行为；但是这个实现很别扭，会让程序员犯错，一不小心传递给另外一个smart_ptr后，你就不再拥有这个对象。
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
copy ctt called
called bool()
ptr_smart has been released
assign ctt called
copy ctt called
rectangle decreated
shape decreated
```

## “移动”指针

使用移动来改善其行为。C++的规则是：如果提供了移动构造函数而没有手动提供拷贝构造函数，那么后者自动被禁用：将smart_ptr&改为了smart_ptr&&，现在成了移动构造函数；把赋值函数中的参数类型由smart_ptr&改为了smart_ptr，在构造参数时生成新的智能指针，移动赋值（这样做的目的是什么？注意570会先调用移动构造构造再调用赋值函数ptr_smart = std::move(ptr_smart2);这个地方还是么有看懂）
```c++
template <typename T>
class smart_ptr {
public:
    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
    ~smart_ptr() { delete ptr_; }
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }

    smart_ptr(smart_ptr&& other) { puts("move-copy ctt called"); ptr_ = other.release(); }
    smart_ptr& operator=(smart_ptr rhs) { puts("assign ctt called"); rhs.swap(*this); return *this; }
    T* release() { T* ptr = ptr_; ptr_ = nullptr; return ptr; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); }
private:
    T* ptr_;

};

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    // auto ptr_smart2 = ptr_smart; compile error;
    auto ptr_smart2(std::move(ptr_smart));
    if (ptr_smart)
    {
        puts("That's good!");
    }
    else {
        puts("ptr_smart has been released");
    }
    ptr_smart = std::move(ptr_smart2);
    smart_ptr<shape> ptr_smart3{ create_shape(shape_type::rectangle) };
    //smart_ptr<shape> ptr_smart4{ ptr_smart3 }; compile error
}
```
结果如下
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
move-copy ctt called
called bool()
ptr_smart has been released
move-copy ctt called
assign ctt called
shape created
rectangle created
rectangle decreated
shape decreated
rectangle decreated
shape decreated
```
以上实现就是C++11中unique_ptr的基本行为，其实跟auto_ptr来看效果上一致的，一个对象最终只被一个unique_ptr拥有，只不过这里避免了程序员犯错，需要显式的移动

## 子类指针向基类指针的转化

在C++中circle\*可以隐式转化为shape\*，但是目前的smart_ptr<circle>却无法转化为smart_ptr<shape>.需要额外再改造下，新增一个构造函数，使用模板
```c++  
  template <typename U>
  smart_ptr(smart_ptr<U>&& other)
  {
    ptr_ = other.release();
  }
```
    
## 三五法则
如果需要析构函数，则必定需要拷贝和赋值。

## 引用计数

unique_ptr是一种较为安全的智能指针，但是一个对象智能被单个unique_ptr所拥有。一种更常见的的情况是多个智能指针同时拥有一个对象，通过引用计数跟踪对象是否失效。这就是shared_ptr了。初步实现如下：注意
- 拷贝构造有两个（一个基于模板，一个不是模板），移动构造只有一个（基于模板），我自己分析，如果拷贝构造只保留一个基于模板的话，编译器会自动再生成一个。
- 模板类的多个实例间不是天然就有friend关系，需要明确说明
- 针对移动构造的情况，不需要增加引用计数
```c++
class shared_count
{
public:
    shared_count() noexcept : count_(1) {}
    void add_count() noexcept { ++count_; }
    long reduce_count() noexcept { return --count_; }
    long get_count() const noexcept { return count_; }
private:
    long count_;

};

template <typename T>
class smart_ptr {
public:
    template <typename U>
    friend class smart_ptr;

    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) 
    {
        puts("ctt called");
        if (ptr) {
            shared_count_ = new shared_count();
        }
    }
    ~smart_ptr() 
    {
        if (ptr_ && !shared_count_->reduce_count()) {
            delete ptr_;
            delete shared_count_;
        }
    }

    smart_ptr(const smart_ptr& other) 
    { 
        puts("copy ctt called"); 
        ptr_ = other.ptr_; 
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr(const smart_ptr<U>& other) noexcept
    {
        puts("cast copy ctt called");
        ptr_ = other.ptr_();
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr( smart_ptr<U>&& other) noexcept
    {
        puts("cast move_copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            shared_count_ = other.shared_count_;
            other.ptr_ = nullptr;
        }
    }
	smart_ptr& operator=(smart_ptr rhs) noexcept { puts("assign copy ctt called");  rhs.swap(*this);    return *this; } // it will call copy ctt first to construct "(smart_ptr rhs)"----copy-and-swap idiom
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
	
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); std::swap(shared_count_, rhs.shared_count_);}
    long use_count() const
    {
        if (ptr_) {
            return shared_count_->get_count();
        }
        else {
            return 0;
        }
    }
private:
    T* ptr_;
    shared_count* shared_count_;

};


int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    printf("count of object is %d\n", ptr_smart.use_count());
    // auto ptr_smart2 = ptr_smart; compile error;
    smart_ptr<shape> ptr_smart2(std::move(ptr_smart));
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart3(ptr_smart2);
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart4{ ptr_smart2 };
    printf("count of object is %d\n", ptr_smart2.use_count());

}
```
输出如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
ctt called
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
count of object is 1
cast move_copy ctt called
count of object is 1
copy ctt called
count of object is 2
copy ctt called
count of object is 3
rectangle decreated
shape decreated
```

## 指针类型转化

对于C++里的不同类型的强制转化，需要实现类似的函数模板。但是转化时需要修改智能指针内部的指针对象，需要增加一个构造函数.然后针对四类强制转化实现四个函数模板
```c++
class shared_count
{
public:
    shared_count() noexcept : count_(1) {}
    void add_count() noexcept { ++count_; }
    long reduce_count() noexcept { return --count_; }
    long get_count() const noexcept { return count_; }
private:
    long count_;

};

template <typename T>
class smart_ptr {
public:
    template <typename U>
    friend class smart_ptr;

    explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) 
    {
        puts("ctt called");
        if (ptr) {
            shared_count_ = new shared_count();
        }
    }
	template <typename U>
	smart_ptr(const smart_ptr<U>& other, T* ptr)
	{
		puts("explicit cast ctt called");
		ptr_ = ptr;
		if (ptr_) {
			other.shared_count_->add_count();
			shared_count_ = other.shared_count_;
		}
	}
    ~smart_ptr() 
    {
        if (ptr_ && !shared_count_->reduce_count()) {
            delete ptr_;
            delete shared_count_;
        }
    }

    smart_ptr(const smart_ptr& other) 
    { 
        puts("copy ctt called"); 
        ptr_ = other.ptr_; 
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr(const smart_ptr<U>& other) noexcept
    {
        puts("cast copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            other.shared_count_->add_count();
            shared_count_ = other.shared_count_;
        }
    }

    template <typename U>
    smart_ptr( smart_ptr<U>&& other) noexcept
    {
        puts("cast move_copy ctt called");
        ptr_ = other.ptr_;
        if (ptr_)
        {
            shared_count_ = other.shared_count_;
            other.ptr_ = nullptr;
        }
    }
	smart_ptr& operator=(smart_ptr rhs) noexcept { puts("assign copy ctt called");  rhs.swap(*this);    return *this; } // it will call copy ctt first to construct "(smart_ptr rhs)"----copy-and-swap idiom
    T* get() const { return ptr_; }
    T& operator*() const { puts("called *"); return *ptr_; }
    T* operator->() const { puts("called ->"); return ptr_; }
    operator bool() const { puts("called bool()"); return ptr_; }
    void swap(smart_ptr& rhs) { std::swap(ptr_, rhs.ptr_); std::swap(shared_count_, rhs.shared_count_);}
    long use_count() const
    {
        if (ptr_) {
            return shared_count_->get_count();
        }
        else {
            return 0;
        }
    }
private:
    T* ptr_;
    shared_count* shared_count_;

};
template <typename T, typename U>
smart_ptr<T> static_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = static_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> reinterpret_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = reinterpret_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> const_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = const_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}
template <typename T, typename U>
smart_ptr<T> dynamic_pointer_cast(const smart_ptr<U>& other) noexcept
{
	T* ptr = dynamic_cast<T*>(other.get());
	return smart_ptr<T>(other, ptr);
}

int main()
{
	shape* aRectangle = create_shape(shape_type::rectangle);
	aRectangle->tell();
	delete aRectangle; // if missed this, then memory leak

    smart_ptr<shape> ptr_smart(create_shape(shape_type::rectangle));
    ptr_smart.get()->tell();
    (*ptr_smart).tell();
    ptr_smart->tell();
    printf("count of object is %d\n", ptr_smart.use_count());
    // auto ptr_smart2 = ptr_smart; compile error;
    smart_ptr<shape> ptr_smart2(std::move(ptr_smart));
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart3(ptr_smart2);
    printf("count of object is %d\n", ptr_smart2.use_count());
    smart_ptr<shape> ptr_smart4{ ptr_smart2 };
    printf("count of object is %d\n", ptr_smart2.use_count());

	smart_ptr<rectangle> rec_ptr(new rectangle());
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
	smart_ptr<shape> shape_ptr = rec_ptr;
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
	smart_ptr<rectangle> rec_ptr2 = dynamic_pointer_cast<rectangle>(shape_ptr);
	printf("count of rec_ptr object is %d\n", rec_ptr.use_count());
}
```
结果如下：
```
shape created
rectangle created
I'am rectangle
rectangle decreated
shape decreated
shape created
rectangle created
ctt called
I'am rectangle
called *
I'am rectangle
called ->
I'am rectangle
count of object is 1
cast move_copy ctt called
count of object is 1
copy ctt called
count of object is 2
copy ctt called
count of object is 3
shape created
rectangle created
ctt called
count of rec_ptr object is 1
cast copy ctt called
count of rec_ptr object is 2
explicit cast ctt called
count of rec_ptr object is 3
rectangle decreated
shape decreated
rectangle decreated
shape decreated
```

## 课后思考

### copy-and-swap idiom
Any class that manages a resource (a wrapper, like a smart pointer) needs to implement The Big Three. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?

The copy-and-swap idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee.
https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550

### shared_ptr应该具备的其他功能

make_shared

# 03 右值和移动究竟解决了什么问题？

移动语义时C++11里引入的重要概念，这个概念时现代C++里优化的基础

## 值分左右

标准里规定了下面这些值类别（value categories）
![C++表达式值类别](https://static001.geekbang.org/resource/image/18/3c/18b692072537d4ce179d3857a8a0133c.png)

- 一个lvalue是通常可以放在等号左边的表达式，左值
- 一个rvalue是通常只能放在等号右边的表达式，右值
- 一个glvalue是generalized lvalue，广义左值
- 一个xvalue是expiring lvaue，将亡值
- 一个prvalue是pure rvalue，纯右值

lvalue：是有标识符、可以取地址的表达式，最常见的情况：
- 变量、函数、或者数据成员的名字
- 返回左值引用的表达式，如++x、x = 1、cout << ' '
- 字符串字面量如“hello world” （因为可以取地址）
函数调用时，左值可以绑定到左值引用的参数T&。常量智能绑定到常左值引用，const T&。

反之，纯右值prvalue是没有标识符/不可取地址的表达式，一般也称之为“临时对象”：
- 返回非引用类型的表达式，如 x++、x + 1、make_shared<int>(42)
- 除字符串字面量之外的字面量，如42、true
在C++11之前右值可以绑定到常左值引用（const lvalue reference）的参数，如conts T&，不能绑定到非常左值引用。C++11后，多了一种以用类型，右值引用，T&&。增加了一种引用类型后，最然增加了复杂性，但也带来了很多优化的可能性。例如，利用重载，让smart_ptr的构造函数有不同的行为(smart_ptr<U>&& other中的other到底算是左值还是右值呢，他有标识符/地址，所以式左值。右值引用的变量式一个左值)
```c++
template <typename U>
smart_ptr(const smart_ptr<U>& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    other.shared_count_->add_count();
    shared_count_ =
      other.shared_count_;
  }
}
template <typename U>
smart_ptr(smart_ptr<U>&& other) noexcept
{
  ptr_ = other.ptr_;
  if (ptr_) {
    shared_count_ =
      other.shared_count_;
    other.ptr_ = nullptr;
  }
}
```

- 以下代码中,第一个表达式 new circle()是一个纯右值；第二个表达式里的std::move(ptr)，把一个左值强制转化成一个右值引用，而不改变其内用。从实用的角度看，就是个强制类型转化，其结果是指向ptr1的右值引用，这样会选择上面第二个重载。我们可以把std::move(ptr)看作是一个由名字的右值，把这种表达式讲座xvalue，其不能取地址
```c++
smart_ptr<shape> ptr1{new circle()};
smart_ptr<shape> ptr2 = std::move(ptr1);
```
值类别（category）和值类型（type）是两个概念，前者指的是左值右值相关的概念；后者是相对引用类型的一个概念，所有的原生类型、枚举、结构、类都代表值类型，引用和指针式引用类型

## 生命周期和表达式类型

一个变乱给的生命周期在超出作用域时结束。那么临时对象（prvalue）呢？一个临时对象会在包含这个临时对象的完整表达式估值完成后按照生成顺序逆序被销毁，除非有生命周期延迟
















